<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Circle Shooter - Nanobots Update (Corrigido)</title>
    <style>
        /* Estilos CSS (sem mudanças significativas da v2, apenas ajustes menores se necessário) */
        body { margin: 0; overflow: hidden; touch-action: none; background-color: #111; display: flex; justify-content: center; align-items: center; height: 100vh; color: white; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; background-color: #222; position: relative; }
        #gameUI { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #cashDisplay { position: absolute; top: 20px; left: 20px; font-size: 24px; text-shadow: 1px 1px 2px black; color: #FFEB3B; font-weight: bold; }
        #health { position: absolute; top: 20px; right: 20px; font-size: 24px; text-shadow: 1px 1px 2px black; }
        #waveIndicator { position: absolute; top: 55px; left: 20px; font-size: 18px; color: #aaa; text-shadow: 1px 1px 1px black; }
        .menuOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; font-size: 48px; pointer-events: auto; z-index: 10; backdrop-filter: blur(4px); transition: opacity 0.3s ease, visibility 0.3s ease; opacity: 0; visibility: hidden; }
        .menuOverlay.visible { opacity: 1; visibility: visible; }
        .menuOverlay h1, .menuOverlay h2 { margin-bottom: 20px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); }
        .menuOverlay button { pointer-events: auto; margin-top: 15px; padding: 12px 25px; font-size: 20px; background-color: #4CAF50; color: white; border: none; border-radius: 8px; cursor: pointer; transition: background-color 0.3s ease, transform 0.1s ease; min-width: 150px; }
        .menuOverlay button:hover:not(:disabled) { background-color: #45a049; transform: scale(1.05); }
        .menuOverlay button:active:not(:disabled) { transform: scale(0.98); }
        .menuOverlay button:disabled { background-color: #555; color: #999; cursor: not-allowed; transform: none; }
        #startScreen {}
        #startScreenButtons { display: flex; gap: 20px; }
        #gameOver {}
        #pauseMenu {}
        .gameButton { pointer-events: auto; position: absolute; padding: 10px 15px; font-size: 16px; background-color: rgba(255, 255, 255, 0.3); color: white; border: none; border-radius: 5px; cursor: pointer; transition: background-color 0.3s ease; z-index: 5; }
        .gameButton:hover { background-color: rgba(255, 255, 255, 0.5); }
        #pauseBtn { bottom: 20px; right: 20px; }
        #upgradePanel { position: absolute; bottom: 20px; left: 20px; background-color: rgba(0, 0, 0, 0.7); padding: 10px 15px; border-radius: 8px; z-index: 5; pointer-events: auto; max-width: 350px; display: none; transition: opacity 0.3s ease; }
        #upgradePanel h3 { margin-top: 0; margin-bottom: 10px; font-size: 16px; color: #FFEB3B; text-align: center; }
        .upgradeItem { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; font-size: 14px; }
        .upgradeItem .info { flex-grow: 1; margin-right: 10px; }
        .upgradeItem .name { font-weight: bold; }
        .upgradeItem .cost { font-size: 13px; color: #FFEB3B; margin-left: 5px; }
        .upgradeItem .details { display: block; font-size: 11px; opacity: 0.8; } /* Classe para descrição */
        .upgradeItem button { padding: 4px 8px; font-size: 12px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; min-width: 60px; transition: background-color 0.2s ease; }
        .upgradeItem button:hover:not(:disabled) { background-color: #45a049; }
        .upgradeItem button:disabled { background-color: #555; color: #999; cursor: not-allowed; }
        .upgradeItem.purchased button, .upgradeItem.maxed button { background-color: #0a631a; color: #ccc; cursor: default; }
        .upgradeItem.purchased button:hover, .upgradeItem.maxed button:hover { background-color: #0a631a; }
        #shopOverlay {}
        #shopOverlay h2 { font-size: 40px; }
        #shopCashOverlay { font-size: 24px; margin-bottom: 20px; color: #FFEB3B; font-weight: bold; }
        #shopItemsContainerOverlay { display: flex; flex-direction: column; gap: 15px; margin-top: 10px; margin-bottom: 20px; max-width: 90%; max-height: 60vh; overflow-y: auto; align-items: center; padding: 0 10px; }
        .shopItemOverlay { background-color: rgba(255, 255, 255, 0.1); padding: 15px; border-radius: 8px; display: flex; justify-content: space-between; align-items: center; width: 90%; max-width: 450px; font-size: 18px; box-shadow: 0 2px 5px rgba(0,0,0,0.3); }
        .shopItemOverlay .description { flex-grow: 1; text-align: left; margin-left: 10px; }
        .shopItemOverlay .description .name { font-weight: bold; display: block; margin-bottom: 3px; }
        .shopItemOverlay .description .details { font-size: 14px; opacity: 0.8; }
        .shopItemOverlay .cost { font-weight: bold; color: #FFEB3B; margin: 0 15px; font-size: 16px; }
        .shopItemOverlay button { font-size: 16px; padding: 8px 15px; margin-top: 0; min-width: 90px; }
        .shopItemOverlay.purchased button, .shopItemOverlay.maxed button { background-color: #0a631a; color: #ccc; cursor: default; }
        .shopItemOverlay.purchased button:hover, .shopItemOverlay.maxed button:hover { background-color: #0a631a; }

        /* Media Query Mobile */
        @media (max-width: 600px) {
            #cashDisplay, #health { font-size: 18px; top: 10px; } #cashDisplay { left: 10px; } #health { right: 10px; }
            #waveIndicator { font-size: 14px; top: 40px; left: 10px; }
            #pauseBtn { font-size: 14px; padding: 8px 10px; bottom: 10px; right: 10px; }
            #upgradePanel { max-width: 220px; padding: 8px 10px; bottom: 10px; left: 10px; }
            #upgradePanel h3 { font-size: 14px; margin-bottom: 8px; }
            .upgradeItem { font-size: 12px; margin-bottom: 5px; } .upgradeItem .info { margin-right: 5px; }
            .upgradeItem .name { font-size: 11px; } .upgradeItem .cost { font-size: 11px; }
            .upgradeItem .details { display: none; } /* Esconde detalhes no painel mobile */
            .upgradeItem button { padding: 3px 6px; font-size: 10px; min-width: 45px; }
            .menuOverlay { font-size: 36px; } .menuOverlay h1 { font-size: 42px; } .menuOverlay h2 { font-size: 38px; }
            .menuOverlay button { font-size: 18px; padding: 10px 20px; }
            #shopItemsContainerOverlay { max-width: 100%; padding: 0 5px; }
            .shopItemOverlay { width: 100%; font-size: 16px; padding: 10px; } .shopItemOverlay .description .details { font-size: 12px; }
            .shopItemOverlay .cost { font-size: 14px; margin: 0 10px; } .shopItemOverlay button { font-size: 14px; padding: 6px 12px; min-width: 70px; }
        }
         /* Estilo para inimigo infectado (pode melhorar) */
         .infected-glow {
             box-shadow: 0 0 15px 5px rgba(76, 175, 80, 0.7); /* Brilho verde */
         }
    </style>
</head>
<body>
    <!-- Elementos da UI -->
    <div id="gameUI">
        <div id="cashDisplay">Cash: 0</div>
        <div id="health">Health: 100</div>
        <div id="waveIndicator">Wave: 0</div>
        <button id="pauseBtn" class="gameButton" style="display: none;">Pause</button>

        <!-- Painel de Upgrades In-Game (visível durante o jogo) -->
        <div id="upgradePanel" style="display: none;">
            <h3>Upgrades</h3>
            <div id="upgradeItemsContainer"></div>
        </div>

        <!-- Menus Overlay -->
        <div id="startScreen" class="menuOverlay visible"> <!-- Começa visível -->
            <h1>Circle Shooter</h1> <!-- Título original ou novo -->
            <div id="startScreenButtons">
                <button id="startBtn">Iniciar Jogo</button>
                <button id="startShopBtn">Loja</button>
            </div>
        </div>

        <div id="gameOver" class="menuOverlay">
            <h2>Game Over</h2>
            <span id="finalCash" style="font-size: 32px; display: block; margin-bottom: 20px;"></span>
            <button id="restartBtn">Tela Inicial</button>
        </div>

        <div id="pauseMenu" class="menuOverlay">
            <h2>Game Paused</h2>
            <button id="resumeBtn">Resume</button>
        </div>

        <!-- Overlay da Loja (acessado da tela inicial) -->
        <div id="shopOverlay" class="menuOverlay">
            <h2>Loja de Upgrades</h2>
            <div id="shopCashOverlay">Cash: 0</div>
            <div id="shopItemsContainerOverlay">
                <!-- Itens da loja overlay serão adicionados aqui -->
            </div>
            <button id="closeShopOverlayBtn">Voltar</button>
        </div>
    </div>

    <!-- Canvas do jogo -->
    <canvas id="gameCanvas"></canvas>

    <script>
        // --- Seletores ---
        const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d');
        const cashElement = document.getElementById('cashDisplay'); const healthElement = document.getElementById('health'); const waveIndicatorElement = document.getElementById('waveIndicator');
        const startScreen = document.getElementById('startScreen'); const startBtn = document.getElementById('startBtn'); const startShopBtn = document.getElementById('startShopBtn');
        const gameOverElement = document.getElementById('gameOver'); const finalCashElement = document.getElementById('finalCash'); const restartBtn = document.getElementById('restartBtn');
        const pauseBtn = document.getElementById('pauseBtn'); const pauseMenu = document.getElementById('pauseMenu'); const resumeBtn = document.getElementById('resumeBtn');
        const upgradePanel = document.getElementById('upgradePanel'); const upgradeItemsContainer = document.getElementById('upgradeItemsContainer');
        const shopOverlay = document.getElementById('shopOverlay'); const shopCashOverlayElement = document.getElementById('shopCashOverlay'); const shopItemsContainerOverlay = document.getElementById('shopItemsContainerOverlay'); const closeShopOverlayBtn = document.getElementById('closeShopOverlayBtn');

        // --- Constantes ---
        const PLAYER_COLOR = '#4CAF50'; const PLAYER_RADIUS = 20;
        const BULLET_COLOR = '#2196F3'; const BULLET_RADIUS = 5; const BASE_BULLET_SPEED = 7; const BASE_BULLET_DAMAGE = 10;
        const ENEMY_CIRCLE_COLOR = '#F44336'; const ENEMY_SQUARE_COLOR = '#FF9800'; const ENEMY_TRIANGLE_COLOR = '#9C27B0';
        const BASE_ENEMY_RADIUS = 15; const BASE_ENEMY_HEALTH = 30; const BASE_ENEMY_SPEED = 0.5; const ENEMY_SPEED_RANDOMNESS = 0.3;
        const SHIELD_COLOR = '#FFEB3B'; const BASE_SHIELD_ACTIVE_DURATION = 5000; const BASE_SHIELD_COOLDOWN_DURATION = 8000; const MAX_WEAPON_LEVEL = 3;
        const BOSS_WAVE_INTERVAL = 10; const BOSS_COLOR = '#E91E63'; const BOSS_HEALTH_MULTIPLIER = 30; const BOSS_RADIUS_MULTIPLIER = 2.5; const BOSS_MINION_SPAWN_COOLDOWN = 6000; const BOSS_MINION_COUNT = 3;
        const POWERUP_DROP_CHANCE = 0.08; const POWERUP_DURATION = 7000;
        const POWERUP_ATTRACTION_SPEED = 4; const POWERUP_ATTRACTION_START_DISTANCE = 150;

        // Custos
        const SHIELD_UNLOCK_COST = 150; const WEAPON_LEVEL_COST = 100; const DAMAGE_UP_COST = 120;
        const FIRE_RATE_COST = 130; const BULLET_SPEED_COST = 90; const SHIELD_DURATION_COST = 110; const SHIELD_COOLDOWN_COST = 140;
        const NANO_BOT_UNLOCK_COST = 250;

        // Valores Upgrades
        const DAMAGE_INCREASE_AMOUNT = 0.20; const FIRE_RATE_INCREASE = 0.15; const BULLET_SPEED_INCREASE = 0.10;
        const SHIELD_DURATION_INCREASE = 1000; const SHIELD_COOLDOWN_DECREASE = 750; const MIN_SHIELD_COOLDOWN = 2000;
        const NANO_BOT_COOLDOWN = 8000; const NANO_BOT_SPEED = 5; const NANO_BOT_INFECTION_TIME = 3000;
        const CONVERTED_DURATION = 10000; const CONVERTED_ENEMY_RADIUS_FACTOR = 0.7; const CONVERTED_SHOOT_COOLDOWN = 1500;
        const CONVERTED_BULLET_SPEED = 4; const CONVERTED_BULLET_RADIUS = 4; const CONVERTED_BULLET_DAMAGE = 5;
        const CONVERTED_BULLET_COLOR = '#00FF00';

        // Chaves LocalStorage
        const STORAGE_KEY_PREFIX = 'circleShooterNano_';
        const STORAGE_KEY_CASH = STORAGE_KEY_PREFIX + 'cash';
        const STORAGE_KEY_SHIELD_UNLOCKED = STORAGE_KEY_PREFIX + 'shieldUnlocked';
        const STORAGE_KEY_WEAPON_LEVEL = STORAGE_KEY_PREFIX + 'weaponLevel';
        const STORAGE_KEY_DAMAGE_MULTIPLIER = STORAGE_KEY_PREFIX + 'damageMultiplier';
        const STORAGE_KEY_FIRE_RATE_LEVEL = STORAGE_KEY_PREFIX + 'fireRateLevel';
        const STORAGE_KEY_BULLET_SPEED_LEVEL = STORAGE_KEY_PREFIX + 'bulletSpeedLevel';
        const STORAGE_KEY_SHIELD_DURATION_LEVEL = STORAGE_KEY_PREFIX + 'shieldDurationLevel';
        const STORAGE_KEY_SHIELD_COOLDOWN_LEVEL = STORAGE_KEY_PREFIX + 'shieldCooldownLevel';
        const STORAGE_KEY_NANO_BOTS_UNLOCKED = STORAGE_KEY_PREFIX + 'nanoBotsUnlocked';

        // --- Estado do Jogo ---
        let cash = 0; let health = 100; let gameState = 'start';
        let enemies = []; let bullets = []; let particles = []; let powerups = []; let nanoBots = [];
        let bossActive = false; let lastEnemySpawnTime = 0; let enemySpawnInterval = 3000; let baseEnemySpawnInterval = 3000; let minEnemySpawnInterval = 400;
        let lastBulletTime = 0; let aimX = 0, aimY = 0; let currentWave = 0;
        let shakeIntensity = 0; let shakeDuration = 0;
        let nanoBotCooldownTimer = 0;

        // --- Estado do Jogador ---
        const player = {
            x: 0, y: 0, radius: PLAYER_RADIUS, color: PLAYER_COLOR,
            shieldUnlocked: false, weaponLevel: 0, damageMultiplier: 1,
            fireRateLevel: 0, bulletSpeedLevel: 0, shieldDurationLevel: 0, shieldCooldownLevel: 0,
            nanoBotsUnlocked: false,
            shieldActive: false, shieldState: 'inactive', shieldTimer: 0,
            activePowerups: {},
        };

        // --- Funções Utilitárias ---
        function lerpColor(colorA, colorB, t) {
             const hexToRgb = hex => hex.match(/\w\w/g).map(x => parseInt(x, 16));
             const rgbToHex = rgb => '#' + rgb.map(x => { const hex = x.toString(16); return hex.length === 1 ? '0' + hex : hex; }).join('');
             const rgbA = hexToRgb(colorA); const rgbB = hexToRgb(colorB);
             const rgb = rgbA.map((start, i) => { const end = rgbB[i]; return Math.round(start + (end - start) * t); });
             return rgbToHex(rgb);
        }

        // --- Funções de Persistência ---
        function loadGameData() {
            cash = parseInt(localStorage.getItem(STORAGE_KEY_CASH) || '0');
            player.shieldUnlocked = localStorage.getItem(STORAGE_KEY_SHIELD_UNLOCKED) === 'true';
            player.weaponLevel = parseInt(localStorage.getItem(STORAGE_KEY_WEAPON_LEVEL) || '0');
            player.damageMultiplier = Math.max(1, parseFloat(localStorage.getItem(STORAGE_KEY_DAMAGE_MULTIPLIER) || '1'));
            player.fireRateLevel = parseInt(localStorage.getItem(STORAGE_KEY_FIRE_RATE_LEVEL) || '0');
            player.bulletSpeedLevel = parseInt(localStorage.getItem(STORAGE_KEY_BULLET_SPEED_LEVEL) || '0');
            player.shieldDurationLevel = parseInt(localStorage.getItem(STORAGE_KEY_SHIELD_DURATION_LEVEL) || '0');
            player.shieldCooldownLevel = parseInt(localStorage.getItem(STORAGE_KEY_SHIELD_COOLDOWN_LEVEL) || '0');
            player.nanoBotsUnlocked = localStorage.getItem(STORAGE_KEY_NANO_BOTS_UNLOCKED) === 'true';
            updateCashDisplay();
        }
        function saveGameData() {
            localStorage.setItem(STORAGE_KEY_CASH, cash.toString());
            localStorage.setItem(STORAGE_KEY_SHIELD_UNLOCKED, player.shieldUnlocked.toString());
            localStorage.setItem(STORAGE_KEY_WEAPON_LEVEL, player.weaponLevel.toString());
            localStorage.setItem(STORAGE_KEY_DAMAGE_MULTIPLIER, player.damageMultiplier.toString());
            localStorage.setItem(STORAGE_KEY_FIRE_RATE_LEVEL, player.fireRateLevel.toString());
            localStorage.setItem(STORAGE_KEY_BULLET_SPEED_LEVEL, player.bulletSpeedLevel.toString());
            localStorage.setItem(STORAGE_KEY_SHIELD_DURATION_LEVEL, player.shieldDurationLevel.toString());
            localStorage.setItem(STORAGE_KEY_SHIELD_COOLDOWN_LEVEL, player.shieldCooldownLevel.toString());
            localStorage.setItem(STORAGE_KEY_NANO_BOTS_UNLOCKED, player.nanoBotsUnlocked.toString());
        }

        // --- Configuração Inicial e Controles ---
        function resizeCanvas() {
            const maxWidth = 1200; const maxHeight = 800;
            const width = Math.min(window.innerWidth - 20, maxWidth); const height = Math.min(window.innerHeight - 20, maxHeight);
            canvas.width = width; canvas.height = height;
            if (!player.x || !player.y || gameState === 'start' || gameState === 'gameOver') { player.x = canvas.width / 2; player.y = canvas.height / 2; }
            aimX = canvas.width / 2; aimY = canvas.height / 2;
            if (gameState === 'playing' || gameState === 'paused') { draw(); }
        }
        window.addEventListener('resize', resizeCanvas);

        function updateAimPosition(event) {
            const rect = canvas.getBoundingClientRect(); let clientX, clientY;
            if (event.touches && event.touches.length > 0) { clientX = event.touches[0].clientX; clientY = event.touches[0].clientY; } else { clientX = event.clientX; clientY = event.clientY; }
            aimX = Math.max(0, Math.min(canvas.width, clientX - rect.left)); aimY = Math.max(0, Math.min(canvas.height, clientY - rect.top));
        }
        canvas.addEventListener('mousemove', (e) => { if (gameState === 'playing') updateAimPosition(e); });
        canvas.addEventListener('touchmove', (e) => { if (gameState === 'playing') { e.preventDefault(); updateAimPosition(e); } }, { passive: false });
        canvas.addEventListener('touchstart', (e) => { if (gameState === 'playing') { e.preventDefault(); updateAimPosition(e); } }, { passive: false });

        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' || e.key === 'p' || e.key === 'P') { if (gameState === 'shoppingOverlay') { closeShopOverlay(); } else if (gameState === 'playing' || gameState === 'paused') { togglePause(); } }
            if (gameState === 'playing') {
                switch(e.key) {
                    case '1': buyUpgradeByIndex(0); break; case '2': buyUpgradeByIndex(1); break; case '3': buyUpgradeByIndex(2); break; case '4': buyUpgradeByIndex(3); break;
                    case '5': buyUpgradeByIndex(4); break; case '6': buyUpgradeByIndex(5); break; case '7': buyUpgradeByIndex(6); break; case '8': buyUpgradeByIndex(7); break; // Atalho 8 para nanobots
                }
            }
        });

        // --- Lógica da Loja Overlay ---
        function openShopOverlay() {
            if (gameState !== 'start') return; gameState = 'shoppingOverlay';
            updateShopOverlayUI(); startScreen.classList.remove('visible'); shopOverlay.classList.add('visible');
        }
        function closeShopOverlay() {
            if (gameState !== 'shoppingOverlay') return; gameState = 'start';
            shopOverlay.classList.remove('visible'); startScreen.classList.add('visible');
        }
        function updateShopOverlayUI() {
            shopCashOverlayElement.textContent = `Cash: ${cash}`; shopItemsContainerOverlay.innerHTML = '';
            upgrades.forEach((upgrade) => { if (upgrade.requiresShield && !player.shieldUnlocked) return; const itemDiv = createShopOverlayItem(upgrade); shopItemsContainerOverlay.appendChild(itemDiv); });
        }
        function createShopOverlayItem(upgrade) {
            const itemDiv = document.createElement('div'); itemDiv.classList.add('shopItemOverlay');
            const purchased = upgrade.isPurchased ? upgrade.isPurchased() : false; const maxed = upgrade.isMaxed ? upgrade.isMaxed() : false;
            const currentCost = purchased || maxed ? 0 : (typeof upgrade.cost === 'function' ? upgrade.cost() : upgrade.cost); const canAfford = cash >= currentCost;
            if (purchased) itemDiv.classList.add('purchased'); if (maxed) itemDiv.classList.add('maxed');
            const descDiv = document.createElement('div'); descDiv.classList.add('description'); const nameSpan = document.createElement('span'); nameSpan.classList.add('name'); nameSpan.textContent = upgrade.name; const detailsSpan = document.createElement('span'); detailsSpan.classList.add('details'); detailsSpan.textContent = upgrade.getDescription(); descDiv.appendChild(nameSpan); descDiv.appendChild(detailsSpan);
            const costSpan = document.createElement('span'); costSpan.classList.add('cost'); costSpan.textContent = purchased ? "Adquirido" : (maxed ? "Max" : `Custo: ${currentCost}`); if (purchased || maxed) costSpan.style.color = '#aaa';
            const buyButton = document.createElement('button'); buyButton.textContent = purchased ? "Adquirido" : (maxed ? "Max" : "Comprar"); buyButton.disabled = !canAfford || purchased || maxed;
            buyButton.onclick = () => { if (!buyButton.disabled) { const success = upgrade.buy(); if (success) { updateCashDisplay(); updateShopOverlayUI(); saveGameData(); } } };
            itemDiv.appendChild(descDiv); itemDiv.appendChild(costSpan); itemDiv.appendChild(buyButton); return itemDiv;
        }

        // --- Event Listeners da UI ---
        startBtn.addEventListener('click', startGame); startShopBtn.addEventListener('click', openShopOverlay);
        closeShopOverlayBtn.addEventListener('click', closeShopOverlay); pauseBtn.addEventListener('click', togglePause);
        resumeBtn.addEventListener('click', togglePause); restartBtn.addEventListener('click', () => {
            gameOverElement.classList.remove('visible'); startScreen.classList.add('visible'); gameState = 'start';
            pauseBtn.style.display = 'none'; upgradePanel.style.display = 'none';
        });

        // --- Funções de Controle do Jogo ---
        function startGame() {
            startScreen.classList.remove('visible'); resetGameSession(); gameState = 'playing'; lastTimestamp = 0;
            pauseBtn.style.display = 'block'; upgradePanel.style.display = 'block'; updateUpgradePanel();
            if (player.shieldUnlocked && player.shieldState === 'inactive') { player.shieldState = 'active'; player.shieldTimer = getCurrentShieldActiveDuration(); player.shieldActive = true; }
            requestAnimationFrame(gameLoop);
        }
        function togglePause() {
            if (gameState === 'playing') { gameState = 'paused'; pauseMenu.classList.add('visible'); pauseBtn.textContent = 'Resume'; upgradePanel.style.opacity = '0'; upgradePanel.style.pointerEvents = 'none'; }
            else if (gameState === 'paused') { gameState = 'playing'; pauseMenu.classList.remove('visible'); pauseBtn.textContent = 'Pause'; upgradePanel.style.opacity = '1'; upgradePanel.style.pointerEvents = 'auto'; lastTimestamp = performance.now(); requestAnimationFrame(gameLoop); }
        }
        function showGameOver() {
            gameState = 'gameOver'; finalCashElement.textContent = `Cash Final: ${cash}`; gameOverElement.classList.add('visible');
            pauseBtn.style.display = 'none'; upgradePanel.style.display = 'none'; saveGameData();
        }
        function resetGameSession() {
            health = 100; enemies = []; bullets = []; particles = []; powerups = []; nanoBots = [];
            bossActive = false; player.activePowerups = {}; player.shieldState = 'inactive'; player.shieldTimer = 0; player.shieldActive = false;
            player.x = canvas.width / 2; player.y = canvas.height / 2; lastEnemySpawnTime = 0; enemySpawnInterval = baseEnemySpawnInterval; currentWave = 0;
            aimX = canvas.width / 2; aimY = canvas.height / 2; nanoBotCooldownTimer = 0;
            updateHealth(); updateWaveIndicator(); ctx.fillStyle = '#222'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // --- Lógica de Upgrades ---
        function getCurrentFireRateCooldown() { const baseCooldown = 350; return baseCooldown / (1 + player.fireRateLevel * FIRE_RATE_INCREASE); }
        function getCurrentBulletSpeed() { return BASE_BULLET_SPEED * (1 + player.bulletSpeedLevel * BULLET_SPEED_INCREASE); }
        function getCurrentShieldActiveDuration() { return BASE_SHIELD_ACTIVE_DURATION + (player.shieldDurationLevel * SHIELD_DURATION_INCREASE); }
        function getCurrentShieldCooldownDuration() { const decreasedCooldown = BASE_SHIELD_COOLDOWN_DURATION - (player.shieldCooldownLevel * SHIELD_COOLDOWN_DECREASE); return Math.max(MIN_SHIELD_COOLDOWN, decreasedCooldown); }

        const upgrades = [
            { id: 'shieldUnlock', name: "Desbloquear Escudo", cost: SHIELD_UNLOCK_COST, isPurchased: () => player.shieldUnlocked, buy: () => { if (cash >= SHIELD_UNLOCK_COST && !player.shieldUnlocked) { cash -= SHIELD_UNLOCK_COST; player.shieldUnlocked = true; player.shieldState = 'active'; player.shieldTimer = getCurrentShieldActiveDuration(); player.shieldActive = true; return true; } return false; }, getDescription: () => `Ativa ${getCurrentShieldActiveDuration()/1000}s, Recarrega ${getCurrentShieldCooldownDuration()/1000}s` },
            { id: 'weaponLevel', name: "Nível Arma", cost: () => WEAPON_LEVEL_COST * (player.weaponLevel + 1), maxLevel: MAX_WEAPON_LEVEL, isMaxed: () => player.weaponLevel >= MAX_WEAPON_LEVEL, buy: () => { const c = upgrades[1].cost(); if (cash >= c && !upgrades[1].isMaxed()) { cash -= c; player.weaponLevel++; return true; } return false; }, getDescription: () => `Projéteis: ${player.weaponLevel}/${MAX_WEAPON_LEVEL}. Próximo Custo: ${upgrades[1].isMaxed() ? 'MAX' : upgrades[1].cost()}` },
            { id: 'damageUp', name: "Dano", cost: () => Math.floor(DAMAGE_UP_COST * (1 + (player.damageMultiplier - 1) / DAMAGE_INCREASE_AMOUNT) * 1.2), buy: () => { const c = upgrades[2].cost(); if (cash >= c) { cash -= c; player.damageMultiplier += DAMAGE_INCREASE_AMOUNT; return true; } return false; }, getDescription: () => `+${(DAMAGE_INCREASE_AMOUNT * 100).toFixed(0)}%. Atual: ${(player.damageMultiplier * 100).toFixed(0)}%. Custo: ${upgrades[2].cost()}` },
            { id: 'fireRate', name: "Cadência", cost: () => FIRE_RATE_COST * (player.fireRateLevel + 1), buy: () => { const c = upgrades[3].cost(); if (cash >= c) { cash -= c; player.fireRateLevel++; return true; } return false; }, getDescription: () => `+${(FIRE_RATE_INCREASE * 100).toFixed(0)}% Vel. Disparo. Nível: ${player.fireRateLevel}. Custo: ${upgrades[3].cost()}` },
            { id: 'bulletSpeed', name: "Vel. Projétil", cost: () => BULLET_SPEED_COST * (player.bulletSpeedLevel + 1), buy: () => { const c = upgrades[4].cost(); if (cash >= c) { cash -= c; player.bulletSpeedLevel++; return true; } return false; }, getDescription: () => `+${(BULLET_SPEED_INCREASE * 100).toFixed(0)}% Vel. Projétil. Nível: ${player.bulletSpeedLevel}. Custo: ${upgrades[4].cost()}` },
            { id: 'shieldDuration', name: "Duração Escudo", cost: () => SHIELD_DURATION_COST * (player.shieldDurationLevel + 1), requiresShield: true, buy: () => { const c = upgrades[5].cost(); if (cash >= c && player.shieldUnlocked) { cash -= c; player.shieldDurationLevel++; return true; } return false; }, getDescription: () => `+${SHIELD_DURATION_INCREASE/1000}s Duração. Atual: ${getCurrentShieldActiveDuration()/1000}s. Custo: ${upgrades[5].cost()}` },
            { id: 'shieldCooldown', name: "Recarga Escudo", cost: () => SHIELD_COOLDOWN_COST * (player.shieldCooldownLevel + 1), requiresShield: true, isMaxed: () => getCurrentShieldCooldownDuration() <= MIN_SHIELD_COOLDOWN, buy: () => { const c = upgrades[6].cost(); if (cash >= c && player.shieldUnlocked && !upgrades[6].isMaxed()) { cash -= c; player.shieldCooldownLevel++; return true; } return false; }, getDescription: () => `-${SHIELD_COOLDOWN_DECREASE/1000}s Recarga. Atual: ${getCurrentShieldCooldownDuration()/1000}s. Custo: ${upgrades[6].isMaxed() ? 'MAX' : upgrades[6].cost()}` },
            { id: 'nanoBots', name: "Nano-Robôs", cost: NANO_BOT_UNLOCK_COST, isPurchased: () => player.nanoBotsUnlocked, buy: () => { if (cash >= NANO_BOT_UNLOCK_COST && !player.nanoBotsUnlocked) { cash -= NANO_BOT_UNLOCK_COST; player.nanoBotsUnlocked = true; nanoBotCooldownTimer = NANO_BOT_COOLDOWN; return true; } return false; }, getDescription: () => `Lança robôs que convertem inimigos. Custo: ${NANO_BOT_UNLOCK_COST}` }
        ];

        function updateUpgradePanel() {
             if (gameState !== 'playing' || upgradePanel.style.display === 'none') return; upgradeItemsContainer.innerHTML = '';
             upgrades.forEach((upgrade, index) => {
                 if (upgrade.requiresShield && !player.shieldUnlocked) return; if (upgrade.id === 'shieldUnlock' && player.shieldUnlocked) return;
                 const itemDiv = document.createElement('div'); itemDiv.classList.add('upgradeItem');
                 const purchased = upgrade.isPurchased ? upgrade.isPurchased() : false; const maxed = upgrade.isMaxed ? upgrade.isMaxed() : false;
                 const currentCost = purchased || maxed ? 0 : (typeof upgrade.cost === 'function' ? upgrade.cost() : upgrade.cost); const canAfford = cash >= currentCost;
                 if (purchased) itemDiv.classList.add('purchased'); if (maxed) itemDiv.classList.add('maxed');
                 const infoDiv = document.createElement('div'); infoDiv.classList.add('info'); const nameSpan = document.createElement('span'); nameSpan.classList.add('name'); nameSpan.textContent = `${index + 1}. ${upgrade.name}`; const descSpan = document.createElement('span'); descSpan.classList.add('details');
                 let panelDesc = '';
                 if (upgrade.id === 'shieldUnlock') panelDesc = `Custo: ${currentCost}`; else if (upgrade.id === 'weaponLevel') panelDesc = `Nível: ${player.weaponLevel}/${MAX_WEAPON_LEVEL}`; else if (upgrade.id === 'damageUp') panelDesc = `Dano: ${(player.damageMultiplier * 100).toFixed(0)}%`; else if (upgrade.id === 'fireRate') panelDesc = `Nível: ${player.fireRateLevel}`; else if (upgrade.id === 'bulletSpeed') panelDesc = `Nível: ${player.bulletSpeedLevel}`; else if (upgrade.id === 'shieldDuration') panelDesc = `Duração: ${getCurrentShieldActiveDuration()/1000}s`; else if (upgrade.id === 'shieldCooldown') panelDesc = `Recarga: ${getCurrentShieldCooldownDuration()/1000}s`; else if (upgrade.id === 'nanoBots') panelDesc = purchased ? `Cooldown: ${NANO_BOT_COOLDOWN/1000}s` : `Custo: ${currentCost}`;
                 descSpan.textContent = panelDesc; infoDiv.appendChild(nameSpan); infoDiv.appendChild(descSpan);
                 const buyButton = document.createElement('button'); let buttonText = purchased ? "OK" : (maxed ? "Max" : `(${currentCost})`); buyButton.textContent = buttonText; buyButton.disabled = !canAfford || purchased || maxed;
                 buyButton.onclick = (e) => { e.stopPropagation(); if (!buyButton.disabled) { const success = upgrade.buy(); if (success) { updateCashDisplay(); saveGameData(); } } };
                 itemDiv.appendChild(infoDiv); itemDiv.appendChild(buyButton); upgradeItemsContainer.appendChild(itemDiv);
             });
        }
        function buyUpgradeByIndex(index) {
             if (gameState !== 'playing' || index < 0 || index >= upgrades.length) return; const upgrade = upgrades[index];
             if (upgrade.requiresShield && !player.shieldUnlocked) return; if (upgrade.id === 'shieldUnlock' && player.shieldUnlocked) return;
             const purchased = upgrade.isPurchased ? upgrade.isPurchased() : false; const maxed = upgrade.isMaxed ? upgrade.isMaxed() : false; if (purchased || maxed) return;
             const currentCost = typeof upgrade.cost === 'function' ? upgrade.cost() : upgrade.cost;
             if (cash >= currentCost) { const success = upgrade.buy(); if (success) { updateCashDisplay(); saveGameData(); } }
        }


        // --- Lógica do Jogo ---
        function createParticles(x, y, count, color, speedMultiplier = 1, lifeMultiplier = 1) { for (let i = 0; i < count; i++) { const angle = Math.random() * Math.PI * 2; const speed = (Math.random() * 3 + 1) * speedMultiplier; const life = (Math.random() * 500 + 300) * lifeMultiplier; particles.push({ x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, radius: Math.random() * 2 + 1, color: color, life: life, maxLife: life, }); } }
        function updateParticles(deltaTime) { for (let i = particles.length - 1; i >= 0; i--) { const p = particles[i]; p.x += p.vx * (deltaTime / 16.67); p.y += p.vy * (deltaTime / 16.67); p.life -= deltaTime; p.vx *= 0.98; p.vy *= 0.98; if (p.life <= 0) { particles.splice(i, 1); } } }
        function triggerShake(intensity, duration) { if (intensity > shakeIntensity) { shakeIntensity = intensity; shakeDuration = duration; } else if (shakeIntensity === 0) { shakeIntensity = intensity; shakeDuration = duration; } }
        function updateShake(deltaTime) { if (shakeDuration > 0) { shakeDuration -= deltaTime; if (shakeDuration <= 0) { shakeIntensity = 0; } } }
        function updateShield(deltaTime) { if (!player.shieldUnlocked) return; const shieldActiveDuration = getCurrentShieldActiveDuration(); const shieldCooldownDuration = getCurrentShieldCooldownDuration(); player.shieldTimer -= deltaTime; if (player.shieldState === 'active' && player.shieldTimer <= 0) { player.shieldState = 'cooldown'; player.shieldTimer = shieldCooldownDuration; player.shieldActive = false; } else if (player.shieldState === 'cooldown' && player.shieldTimer <= 0) { if (!player.activePowerups.shieldBoost) { player.shieldState = 'active'; player.shieldTimer = shieldActiveDuration; player.shieldActive = true; } else { player.shieldTimer = 0.1; } } if (player.activePowerups.shieldBoost && !player.shieldActive) { player.shieldActive = true; player.shieldState = 'active'; } }
        function updateActivePowerups(deltaTime) { const now = Date.now(); for (const type in player.activePowerups) { if (now > player.activePowerups[type]) { const endedType = type; delete player.activePowerups[type]; if (endedType === 'rapidFire') player.color = PLAYER_COLOR; if (endedType === 'shieldBoost' && player.shieldUnlocked) { player.shieldActive = false; updateShield(0); } } } }
        function spawnPowerup(x, y) { const types = ['rapidFire', 'shieldBoost', 'cashBoost']; const type = types[Math.floor(Math.random() * types.length)]; let color = '#FFFFFF', symbol = '?'; switch (type) { case 'rapidFire': color = '#FFFF00'; symbol = '>>'; break; case 'shieldBoost': color = SHIELD_COLOR; symbol = 'S'; break; case 'cashBoost': color = '#FFEB3B'; symbol = '$'; break; } powerups.push({ x, y, radius: 10, color: color, symbol: symbol, type: type, life: 10000 }); }
        function spawnEnemy() { const now = Date.now(); if (bossActive || now - lastEnemySpawnTime < enemySpawnInterval) return; lastEnemySpawnTime = now; if (!(currentWave > 0 && (currentWave + 1) % BOSS_WAVE_INTERVAL === 0)) { currentWave++; updateWaveIndicator(); } if (currentWave > 0 && currentWave % BOSS_WAVE_INTERVAL === 0 && !bossActive) { spawnBoss(); baseEnemySpawnInterval = Math.max(minEnemySpawnInterval, baseEnemySpawnInterval * 0.9); enemySpawnInterval = baseEnemySpawnInterval * 1.5; return; } if (bossActive) return; const edge = Math.floor(Math.random() * 4); let x, y; const radius = BASE_ENEMY_RADIUS + Math.random() * 5; switch (edge) { case 0: x = Math.random() * canvas.width; y = -radius; break; case 1: x = canvas.width + radius; y = Math.random() * canvas.height; break; case 2: x = Math.random() * canvas.width; y = canvas.height + radius; break; case 3: x = -radius; y = Math.random() * canvas.height; break; } let enemyType = 'circle', color = ENEMY_CIRCLE_COLOR, speedMultiplier = 1.0, healthMultiplier = 1.0; const typeRoll = Math.random(); if (currentWave > 5 && typeRoll < 0.3) { enemyType = 'square'; color = ENEMY_SQUARE_COLOR; speedMultiplier = 0.8; healthMultiplier = 1.5; } else if (currentWave > 10 && typeRoll < 0.5) { enemyType = 'triangle'; color = ENEMY_TRIANGLE_COLOR; speedMultiplier = 1.3; healthMultiplier = 0.8; } const speed = (BASE_ENEMY_SPEED + Math.random() * ENEMY_SPEED_RANDOMNESS) * speedMultiplier; const healthBonusPerWave = 1 + Math.floor(currentWave / 5); const enemyHealth = (BASE_ENEMY_HEALTH + currentWave * healthBonusPerWave) * healthMultiplier; enemies.push({ x: x, y: y, radius: radius, color: color, speed: speed, type: enemyType, health: enemyHealth, maxHealth: enemyHealth, updateDirection: function(deltaTime) { const angle = Math.atan2(player.y - this.y, player.x - this.x); const angleOffset = this.type === 'triangle' ? (Math.random() - 0.5) * 0.2 : 0; this.dx = Math.cos(angle + angleOffset) * this.speed; this.dy = Math.sin(angle + angleOffset) * this.speed; }, takeDamage: function(amount) { this.health -= amount; createParticles(this.x, this.y, 1, '#FF9999', 0.5, 0.5); return this.health <= 0; }, die: function() { if (Math.random() < POWERUP_DROP_CHANCE) { spawnPowerup(this.x, this.y); } const cashGained = 5 + Math.floor(this.maxHealth / 20); cash += cashGained; updateCashDisplay(); createParticles(this.x, this.y, 15, this.color, 1.2, 1.0); saveGameData(); } }); if (enemySpawnInterval > minEnemySpawnInterval) { const reductionFactor = 1 - (0.01 + currentWave * 0.0005); enemySpawnInterval = Math.max(minEnemySpawnInterval, enemySpawnInterval * reductionFactor); } }
        function spawnBoss() { currentWave++; updateWaveIndicator(); bossActive = true; const radius = BASE_ENEMY_RADIUS * BOSS_RADIUS_MULTIPLIER; const health = (BASE_ENEMY_HEALTH + currentWave * (1 + Math.floor(currentWave / 5))) * BOSS_HEALTH_MULTIPLIER; const speed = BASE_ENEMY_SPEED * 0.5; enemies.push({ x: canvas.width / 2, y: -radius * 2, radius: radius, color: BOSS_COLOR, speed: speed, type: 'boss', health: health, maxHealth: health, isBoss: true, minionSpawnTimer: BOSS_MINION_SPAWN_COOLDOWN / 2, minionSpawnCooldown: BOSS_MINION_SPAWN_COOLDOWN, updateDirection: function(deltaTime) { const angle = Math.atan2(player.y - this.y, player.x - this.x); this.dx = Math.cos(angle) * this.speed; this.dy = Math.sin(angle) * this.speed; this.minionSpawnTimer += deltaTime; if (this.minionSpawnTimer >= this.minionSpawnCooldown) { this.minionSpawnTimer = 0; spawnMinionsAroundBoss(this); createParticles(this.x, this.y, 20, this.color, 0.8, 0.8); } }, takeDamage: function(amount) { this.health -= amount; createParticles(this.x + (Math.random()-0.5)*this.radius, this.y + (Math.random()-0.5)*this.radius, 3, '#FFCCCC', 0.8, 0.8); return this.health <= 0; }, die: function() { bossActive = false; const cashGained = 150 + Math.floor(this.maxHealth / 10); cash += cashGained; updateCashDisplay(); spawnPowerup(this.x - 30, this.y); spawnPowerup(this.x + 30, this.y); spawnPowerup(this.x, this.y - 30); createParticles(this.x, this.y, 100, this.color, 2.5, 1.5); triggerShake(15, 800); saveGameData(); lastEnemySpawnTime = Date.now(); } }); }
        function spawnMinionsAroundBoss(boss) { for (let i = 0; i < BOSS_MINION_COUNT; i++) { const angle = (Math.PI * 2 / BOSS_MINION_COUNT) * i + (Math.random() * 0.5 - 0.25); const spawnDist = boss.radius * 1.2; const x = boss.x + Math.cos(angle) * spawnDist; const y = boss.y + Math.sin(angle) * spawnDist; const minionHealth = BASE_ENEMY_HEALTH * 0.5 + currentWave * 2; const minionSpeed = BASE_ENEMY_SPEED * 1.2; enemies.push({ x: x, y: y, radius: BASE_ENEMY_RADIUS * 0.8, color: ENEMY_CIRCLE_COLOR, speed: minionSpeed, type: 'circle', health: minionHealth, maxHealth: minionHealth, updateDirection: function(deltaTime) { const angle = Math.atan2(player.y - this.y, player.x - this.x); this.dx = Math.cos(angle) * this.speed; this.dy = Math.sin(angle) * this.speed; }, takeDamage: function(amount) { this.health -= amount; createParticles(this.x, this.y, 1, '#FF9999', 0.5, 0.5); return this.health <= 0; }, die: function() { createParticles(this.x, this.y, 8, this.color, 1.0, 0.8); } }); } }
        function updatePowerups(deltaTime) { for (let i = powerups.length - 1; i >= 0; i--) { const powerup = powerups[i]; powerup.life -= deltaTime; const dx = player.x - powerup.x; const dy = player.y - powerup.y; const distance = Math.sqrt(dx * dx + dy * dy); if (distance < POWERUP_ATTRACTION_START_DISTANCE) { const speed = POWERUP_ATTRACTION_SPEED * (1 + (1 - distance/POWERUP_ATTRACTION_START_DISTANCE)); if (distance > 1) { powerup.x += (dx / distance) * speed * (deltaTime / 16.67); powerup.y += (dy / distance) * speed * (deltaTime / 16.67); } } if (distance < player.radius + powerup.radius) { player.activePowerups[powerup.type] = Date.now() + POWERUP_DURATION; if (powerup.type === 'rapidFire') player.color = '#FFFF00'; if (powerup.type === 'cashBoost') { const cashBonus = 50 + Math.floor(Math.random() * 51); cash += cashBonus; updateCashDisplay(); saveGameData(); createParticles(player.x, player.y, 15, '#FFEB3B'); } createParticles(powerup.x, powerup.y, 10, powerup.color); powerups.splice(i, 1); continue; } if (powerup.life <= 0) { powerups.splice(i, 1); } } }
        function launchNanoBot() { if (!player.nanoBotsUnlocked || nanoBotCooldownTimer > 0 || nanoBots.length > 0) { return; } let targetEnemy = null; let maxHealth = -1; for (const enemy of enemies) { if (!enemy.isConverted && !enemy.isBoss && enemy.health > maxHealth) { let alreadyTargeted = false; for(const bot of nanoBots) { if (bot.targetEnemy === enemy) { alreadyTargeted = true; break; } } if (!alreadyTargeted) { maxHealth = enemy.health; targetEnemy = enemy; } } } if (targetEnemy) { nanoBots.push({ x: player.x, y: player.y, radius: 4, color: '#00BCD4', targetEnemy: targetEnemy, state: 'seeking', infectionProgress: 0, speed: NANO_BOT_SPEED }); nanoBotCooldownTimer = NANO_BOT_COOLDOWN; createParticles(player.x, player.y, 5, '#00BCD4', 0.8, 0.5); } }
        function updateNanoBots(deltaTime) { if (nanoBotCooldownTimer > 0) { nanoBotCooldownTimer -= deltaTime; } for (let i = nanoBots.length - 1; i >= 0; i--) { const bot = nanoBots[i]; const target = bot.targetEnemy; if (!target || target.health <= 0 || target.isConverted) { createParticles(bot.x, bot.y, 5, bot.color, 0.5, 0.5); nanoBots.splice(i, 1); continue; } if (bot.state === 'seeking') { const dx = target.x - bot.x; const dy = target.y - bot.y; const distance = Math.sqrt(dx * dx + dy * dy); if (distance < bot.radius + target.radius) { bot.state = 'infecting'; createParticles(target.x, target.y, 8, bot.color, 0.7, 0.8); } else { bot.x += (dx / distance) * bot.speed * (deltaTime / 16.67); bot.y += (dy / distance) * bot.speed * (deltaTime / 16.67); } } else if (bot.state === 'infecting') { bot.x = target.x + (Math.random() - 0.5) * target.radius * 0.5; bot.y = target.y + (Math.random() - 0.5) * target.radius * 0.5; bot.infectionProgress += deltaTime / NANO_BOT_INFECTION_TIME; target.infectionProgress = bot.infectionProgress; if (bot.infectionProgress >= 1) { convertEnemy(target); nanoBots.splice(i, 1); } } } }
        function convertEnemy(enemy) { if (enemy.isConverted) return; enemy.isConverted = true; enemy.originalColor = enemy.color; enemy.color = PLAYER_COLOR; enemy.originalRadius = enemy.radius; enemy.radius *= CONVERTED_ENEMY_RADIUS_FACTOR; enemy.speed = 0; enemy.dx = 0; enemy.dy = 0; enemy.convertedTimer = CONVERTED_DURATION; enemy.shootTimer = Math.random() * CONVERTED_SHOOT_COOLDOWN; enemy.targetConvertedEnemy = null; delete enemy.infectionProgress; createParticles(enemy.x, enemy.y, 20, PLAYER_COLOR, 1.2, 1.0); }
        function updateEnemies(deltaTime) { updateShield(deltaTime); for (let i = enemies.length - 1; i >= 0; i--) { const enemy = enemies[i]; if (enemy.isConverted) { enemy.convertedTimer -= deltaTime; if (enemy.convertedTimer <= 0) { createParticles(enemy.x, enemy.y, 15, enemy.color, 1, 1); enemies.splice(i, 1); continue; } enemy.shootTimer -= deltaTime; if (enemy.shootTimer <= 0) { let closestEnemy = null; let minDistSq = Infinity; for (const otherEnemy of enemies) { if (!otherEnemy.isConverted && otherEnemy !== enemy) { const dx = otherEnemy.x - enemy.x; const dy = otherEnemy.y - enemy.y; const distSq = dx * dx + dy * dy; if (distSq < minDistSq) { minDistSq = distSq; closestEnemy = otherEnemy; } } } if (closestEnemy) { const angle = Math.atan2(closestEnemy.y - enemy.y, closestEnemy.x - enemy.x); bullets.push({ x: enemy.x, y: enemy.y, radius: CONVERTED_BULLET_RADIUS, color: CONVERTED_BULLET_COLOR, speed: CONVERTED_BULLET_SPEED, damage: CONVERTED_BULLET_DAMAGE, dx: Math.cos(angle) * CONVERTED_BULLET_SPEED, dy: Math.sin(angle) * CONVERTED_BULLET_SPEED, isConvertedBullet: true }); enemy.shootTimer = CONVERTED_SHOOT_COOLDOWN + (Math.random() - 0.5) * 500; createParticles(enemy.x, enemy.y, 2, CONVERTED_BULLET_COLOR, 0.5, 0.5); } else { enemy.shootTimer = 500; } } } else { enemy.updateDirection(deltaTime); enemy.x += enemy.dx * (deltaTime / 16.67); enemy.y += enemy.dy * (deltaTime / 16.67); const dx = player.x - enemy.x; const dy = player.y - enemy.y; const distance = Math.sqrt(dx * dx + dy * dy); if (distance < player.radius + enemy.radius) { if (player.shieldActive) { const shieldDamage = 5 + player.shieldDurationLevel; const died = enemy.takeDamage(shieldDamage); createParticles(enemy.x, enemy.y, 5, SHIELD_COLOR, 1, 0.7); if (died && !enemy.isBoss) { enemy.die(); enemies.splice(i, 1); } else { const pushAngle = Math.atan2(enemy.y - player.y, enemy.x - player.x); enemy.x += Math.cos(pushAngle) * 5; enemy.y += Math.sin(pushAngle) * 5; } } else { const damageTaken = enemy.isBoss ? 30 : 15; health -= damageTaken; triggerShake(enemy.isBoss ? 10 : 5, 200); createParticles(player.x, player.y, 10, '#FF0000', 1.5, 1.0); updateHealth(); if (!enemy.isBoss) { enemy.die(); enemies.splice(i, 1); } else { const pushAngle = Math.atan2(enemy.y - player.y, enemy.x - player.x); enemy.x += Math.cos(pushAngle) * 15; enemy.y += Math.sin(pushAngle) * 15; } if (health <= 0) { health = 0; updateHealth(); showGameOver(); return; } } continue; } } } }
        function shoot() { const now = Date.now(); const currentBulletCooldown = player.activePowerups.rapidFire ? getCurrentFireRateCooldown() / 2 : getCurrentFireRateCooldown(); if (now - lastBulletTime < currentBulletCooldown) return; lastBulletTime = now; const angle = Math.atan2(aimY - player.y, aimX - player.x); const speed = getCurrentBulletSpeed(); const damage = BASE_BULLET_DAMAGE * player.damageMultiplier; bullets.push({ x: player.x, y: player.y, radius: BULLET_RADIUS, color: BULLET_COLOR, speed: speed, damage: damage, dx: Math.cos(angle) * speed, dy: Math.sin(angle) * speed }); if (player.weaponLevel >= 1) { bullets.push({ x: player.x, y: player.y, radius: BULLET_RADIUS, color: BULLET_COLOR, speed: speed, damage: damage, dx: Math.cos(angle + 0.2) * speed, dy: Math.sin(angle + 0.2) * speed }); bullets.push({ x: player.x, y: player.y, radius: BULLET_RADIUS, color: BULLET_COLOR, speed: speed, damage: damage, dx: Math.cos(angle - 0.2) * speed, dy: Math.sin(angle - 0.2) * speed }); } if (player.weaponLevel >= 2) { bullets.push({ x: player.x, y: player.y, radius: BULLET_RADIUS * 0.8, color: '#ADD8E6', speed: speed * 0.8, damage: damage * 0.7, dx: Math.cos(angle + 0.8) * speed * 0.8, dy: Math.sin(angle + 0.8) * speed * 0.8 }); bullets.push({ x: player.x, y: player.y, radius: BULLET_RADIUS * 0.8, color: '#ADD8E6', speed: speed * 0.8, damage: damage * 0.7, dx: Math.cos(angle - 0.8) * speed * 0.8, dy: Math.sin(angle - 0.8) * speed * 0.8 }); } if (player.weaponLevel >= 3) { for (let i = 0; i < 2; i++) { const randomAngle = angle + (Math.random() - 0.5) * 0.3; const randomSpeed = speed * (0.9 + Math.random() * 0.2); bullets.push({ x: player.x, y: player.y, radius: BULLET_RADIUS * (0.9 + Math.random()*0.2), color: BULLET_COLOR, speed: randomSpeed, damage: damage * 0.8, dx: Math.cos(randomAngle) * randomSpeed, dy: Math.sin(randomAngle) * randomSpeed }); } } createParticles(player.x + Math.cos(angle)*player.radius, player.y + Math.sin(angle)*player.radius, 1, BULLET_COLOR, 0.5, 0.3); }
        function updateBullets(deltaTime) { for (let i = bullets.length - 1; i >= 0; i--) { const bullet = bullets[i]; bullet.x += bullet.dx * (deltaTime / 16.67); bullet.y += bullet.dy * (deltaTime / 16.67); let bulletRemoved = false; if (!bullet.isConvertedBullet) { for (let j = enemies.length - 1; j >= 0; j--) { const enemy = enemies[j]; if (enemy.isConverted) continue; const dx = bullet.x - enemy.x; const dy = bullet.y - enemy.y; const distance = Math.sqrt(dx * dx + dy * dy); if (distance < bullet.radius + enemy.radius) { const died = enemy.takeDamage(bullet.damage); createParticles(bullet.x, bullet.y, 3, enemy.color, 0.8, 0.6); bullets.splice(i, 1); bulletRemoved = true; if (died) { enemy.die(); enemies.splice(j, 1); } break; } } } else { for (let j = enemies.length - 1; j >= 0; j--) { const enemy = enemies[j]; if (enemy.isConverted) continue; const dx = bullet.x - enemy.x; const dy = bullet.y - enemy.y; const distance = Math.sqrt(dx * dx + dy * dy); if (distance < bullet.radius + enemy.radius) { const died = enemy.takeDamage(bullet.damage); createParticles(bullet.x, bullet.y, 2, CONVERTED_BULLET_COLOR, 0.6, 0.5); bullets.splice(i, 1); bulletRemoved = true; if (died) { enemy.die(); enemies.splice(j, 1); } break; } } } if (!bulletRemoved && (bullet.x < -bullet.radius || bullet.x > canvas.width + bullet.radius || bullet.y < -bullet.radius || bullet.y > canvas.height + bullet.radius)) { bullets.splice(i, 1); } } }

        // --- Desenho ---
        function draw() {
            let shakeX = 0, shakeY = 0; if (shakeIntensity > 0) { shakeX = (Math.random() - 0.5) * 2 * shakeIntensity; shakeY = (Math.random() - 0.5) * 2 * shakeIntensity; }
            ctx.save(); ctx.translate(shakeX, shakeY);
            ctx.fillStyle = '#222'; ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Partículas e Powerups
            ctx.globalAlpha = 0.8; for (const p of particles) { ctx.beginPath(); ctx.arc(p.x, p.y, p.radius * (p.life / p.maxLife), 0, Math.PI * 2); ctx.fillStyle = p.color; ctx.fill(); } ctx.globalAlpha = 1.0;
            for (const powerup of powerups) { ctx.beginPath(); ctx.arc(powerup.x, powerup.y, powerup.radius, 0, Math.PI * 2); ctx.fillStyle = powerup.color; ctx.fill(); ctx.fillStyle = '#000'; ctx.font = `bold ${powerup.radius * 1.2}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(powerup.symbol, powerup.x, powerup.y + 1); const lifePercent = powerup.life / 10000; const barWidth = powerup.radius * 2; const barHeight = 3; ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'; ctx.fillRect(powerup.x - barWidth / 2, powerup.y + powerup.radius + 2, barWidth, barHeight); ctx.fillStyle = powerup.color; ctx.fillRect(powerup.x - barWidth / 2, powerup.y + powerup.radius + 2, barWidth * lifePercent, barHeight); }

            // NanoBots
            ctx.fillStyle = '#00BCD4'; ctx.strokeStyle = '#FFFFFF'; ctx.lineWidth = 1;
            for (const bot of nanoBots) { ctx.beginPath(); const size = bot.radius * 1.5; ctx.moveTo(bot.x, bot.y - size); ctx.lineTo(bot.x + size, bot.y); ctx.lineTo(bot.x, bot.y + size); ctx.lineTo(bot.x - size, bot.y); ctx.closePath(); ctx.fill(); ctx.stroke(); }

            // Jogador, Aura, Escudo
            ctx.beginPath(); ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2); ctx.fillStyle = player.activePowerups.rapidFire ? '#FFFF00' : PLAYER_COLOR; ctx.fill();
            if (player.weaponLevel > 0) { const auraMaxRadius = player.radius + 5 + (player.weaponLevel * 3); const gradient = ctx.createRadialGradient( player.x, player.y, player.radius, player.x, player.y, auraMaxRadius ); const auraColor = '#FFA000'; gradient.addColorStop(0, auraColor + '00'); gradient.addColorStop(0.7, auraColor + '30'); gradient.addColorStop(1, auraColor + '00'); ctx.beginPath(); ctx.arc(player.x, player.y, auraMaxRadius, 0, Math.PI * 2); ctx.fillStyle = gradient; ctx.fill(); }
            if (player.shieldUnlocked) { const shieldBaseRadius = player.radius + 8; if (player.shieldActive) { ctx.beginPath(); const pulse = Math.sin(Date.now() * 0.005) * 2; ctx.arc(player.x, player.y, shieldBaseRadius + pulse, 0, Math.PI * 2); ctx.strokeStyle = SHIELD_COLOR + 'B0'; ctx.lineWidth = 4; ctx.shadowColor = SHIELD_COLOR; ctx.shadowBlur = 15; ctx.stroke(); ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; } else if (player.shieldState === 'cooldown') { ctx.beginPath(); const cooldownDuration = getCurrentShieldCooldownDuration(); const remainingCooldown = player.shieldTimer; const cooldownPercent = Math.max(0, remainingCooldown / cooldownDuration); const startAngle = -Math.PI / 2; const endAngle = startAngle + (Math.PI * 2 * (1 - cooldownPercent)); ctx.arc(player.x, player.y, shieldBaseRadius + 1, startAngle, endAngle); ctx.strokeStyle = '#AAAAAA60'; ctx.lineWidth = 5; ctx.stroke(); } }

            // Inimigos
            for (const enemy of enemies) {
                ctx.save(); ctx.beginPath(); let drawColor = enemy.color; let drawRadius = enemy.radius;
                // Efeito Infecção/Conversão
                if (enemy.infectionProgress > 0 && enemy.infectionProgress < 1) {
                    drawColor = lerpColor(enemy.color, PLAYER_COLOR, enemy.infectionProgress);
                    const infectionPulse = Math.sin(Date.now() * 0.01 + enemy.infectionProgress * Math.PI) * 3;
                    ctx.shadowColor = '#00BCD4'; // <<<<<< CORREÇÃO APLICADA AQUI
                    ctx.shadowBlur = 5 + infectionPulse;
                } else if (enemy.isConverted) {
                    drawColor = PLAYER_COLOR; drawRadius = enemy.originalRadius * CONVERTED_ENEMY_RADIUS_FACTOR;
                    ctx.shadowColor = CONVERTED_BULLET_COLOR; ctx.shadowBlur = 8;
                }
                // Desenha Forma
                if (enemy.isConverted) { ctx.arc(enemy.x, enemy.y, drawRadius, 0, Math.PI * 2); }
                else if (enemy.type === 'circle' || enemy.isBoss) { ctx.arc(enemy.x, enemy.y, drawRadius, 0, Math.PI * 2); }
                else if (enemy.type === 'square') { ctx.rect(enemy.x - drawRadius, enemy.y - drawRadius, drawRadius * 2, drawRadius * 2); }
                else if (enemy.type === 'triangle') { const angleOffset = Date.now() * 0.001; for (let i = 0; i < 3; i++) { const angle = (i * 2 * Math.PI / 3) + angleOffset; const px = enemy.x + Math.cos(angle) * drawRadius * 1.2; const py = enemy.y + Math.sin(angle) * drawRadius * 1.2; if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py); } ctx.closePath(); }
                // Preenche e Limpa Sombra
                ctx.fillStyle = drawColor; ctx.fill(); ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0;
                // Barra de Vida
                if (!enemy.isConverted && enemy.health < enemy.maxHealth) { const healthPercent = Math.max(0, enemy.health / enemy.maxHealth); const barWidth = enemy.radius * (enemy.isBoss ? 1.8 : 1.5); const barHeight = enemy.isBoss ? 6 : 4; const barYOffset = enemy.isBoss ? 8 : 3; const barX = enemy.x - barWidth / 2; const barY = enemy.y - enemy.radius - barHeight - barYOffset; const currentHealthWidth = barWidth * healthPercent; ctx.fillStyle = '#555'; ctx.fillRect(barX, barY, barWidth, barHeight); if (healthPercent > 0.6) ctx.fillStyle = '#00FF00'; else if (healthPercent > 0.3) ctx.fillStyle = '#FFFF00'; else ctx.fillStyle = '#FF0000'; ctx.fillRect(barX, barY, currentHealthWidth, barHeight); ctx.strokeStyle = '#222'; ctx.lineWidth = 1; ctx.strokeRect(barX, barY, barWidth, barHeight); }
                ctx.restore();
            }

            // Balas
            for (const bullet of bullets) { ctx.beginPath(); ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2); ctx.fillStyle = bullet.color; ctx.shadowColor = bullet.color; ctx.shadowBlur = bullet.isConvertedBullet ? 4 : 6; ctx.fill(); ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; }

            ctx.restore(); // Restaura contexto (remove shake)
        }

        // --- UI Updates ---
        function updateCashDisplay() {
             cashElement.textContent = `Cash: ${cash}`;
             if (gameState === 'playing') { updateUpgradePanel(); }
             if (gameState === 'shoppingOverlay') { shopCashOverlayElement.textContent = `Cash: ${cash}`; updateShopOverlayUI(); }
         }
        function updateHealth() {
             healthElement.textContent = `Health: ${health}`; const healthPercent = health / 100;
             if (healthPercent > 0.6) healthElement.style.color = 'white'; else if (healthPercent > 0.3) healthElement.style.color = 'yellow'; else healthElement.style.color = 'red';
         }
        function updateWaveIndicator() { waveIndicatorElement.textContent = `Wave: ${currentWave}`; }

        // --- Game Loop Principal ---
        let lastTimestamp = 0;
        function gameLoop(timestamp) {
             const deltaTime = Math.min(100, (lastTimestamp === 0) ? 16.67 : timestamp - lastTimestamp);
             lastTimestamp = timestamp;
             if (gameState !== 'playing') { if(gameState === 'paused') { lastTimestamp = 0; } if (gameState === 'gameOver' || gameState === 'paused') { draw(); } return; }
            // Atualizações Lógicas
            updateShake(deltaTime); updateActivePowerups(deltaTime);
            launchNanoBot(); updateNanoBots(deltaTime);
            spawnEnemy(); updateEnemies(deltaTime); updatePowerups(deltaTime);
            shoot(); updateBullets(deltaTime); updateParticles(deltaTime);
            // Desenho
            draw();
            requestAnimationFrame(gameLoop);
        }

        // --- Início ---
        loadGameData(); resizeCanvas();
        startScreen.classList.add('visible'); gameOverElement.classList.remove('visible'); pauseMenu.classList.remove('visible'); shopOverlay.classList.remove('visible');
        pauseBtn.style.display = 'none'; upgradePanel.style.display = 'none';
        updateHealth(); updateWaveIndicator();

    </script>
</body>
</html>
