<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Circle Shooter - Nanobots Update</title>
    <style>
        /* Estilos CSS (sem mudanças significativas da v2, apenas ajustes menores se necessário) */
        body { margin: 0; overflow: hidden; touch-action: none; background-color: #111; display: flex; justify-content: center; align-items: center; height: 100vh; color: white; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; background-color: #222; position: relative; }
        #gameUI { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #cashDisplay { position: absolute; top: 20px; left: 20px; font-size: 24px; text-shadow: 1px 1px 2px black; color: #FFEB3B; font-weight: bold; }
        #health { position: absolute; top: 20px; right: 20px; font-size: 24px; text-shadow: 1px 1px 2px black; }
        #waveIndicator { position: absolute; top: 55px; left: 20px; font-size: 18px; color: #aaa; text-shadow: 1px 1px 1px black; }
        .menuOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; font-size: 48px; pointer-events: auto; z-index: 10; backdrop-filter: blur(4px); transition: opacity 0.3s ease, visibility 0.3s ease; opacity: 0; visibility: hidden; }
        .menuOverlay.visible { opacity: 1; visibility: visible; }
        .menuOverlay h1, .menuOverlay h2 { margin-bottom: 20px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); }
        .menuOverlay button { pointer-events: auto; margin-top: 15px; padding: 12px 25px; font-size: 20px; background-color: #4CAF50; color: white; border: none; border-radius: 8px; cursor: pointer; transition: background-color 0.3s ease, transform 0.1s ease; min-width: 150px; }
        .menuOverlay button:hover:not(:disabled) { background-color: #45a049; transform: scale(1.05); }
        .menuOverlay button:active:not(:disabled) { transform: scale(0.98); }
        .menuOverlay button:disabled { background-color: #555; color: #999; cursor: not-allowed; transform: none; }
        #startScreen {}
        #startScreenButtons { display: flex; gap: 20px; }
        #gameOver {}
        #pauseMenu {}
        .gameButton { pointer-events: auto; position: absolute; padding: 10px 15px; font-size: 16px; background-color: rgba(255, 255, 255, 0.3); color: white; border: none; border-radius: 5px; cursor: pointer; transition: background-color 0.3s ease; z-index: 5; }
        .gameButton:hover { background-color: rgba(255, 255, 255, 0.5); }
        #pauseBtn { bottom: 20px; right: 20px; }
        #upgradePanel { position: absolute; bottom: 20px; left: 20px; background-color: rgba(0, 0, 0, 0.7); padding: 10px 15px; border-radius: 8px; z-index: 5; pointer-events: auto; max-width: 350px; display: none; transition: opacity 0.3s ease; }
        #upgradePanel h3 { margin-top: 0; margin-bottom: 10px; font-size: 16px; color: #FFEB3B; text-align: center; }
        .upgradeItem { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; font-size: 14px; }
        .upgradeItem .info { flex-grow: 1; margin-right: 10px; }
        .upgradeItem .name { font-weight: bold; }
        .upgradeItem .cost { font-size: 13px; color: #FFEB3B; margin-left: 5px; }
        .upgradeItem .details { display: block; font-size: 11px; opacity: 0.8; } /* Classe para descrição */
        .upgradeItem button { padding: 4px 8px; font-size: 12px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; min-width: 60px; transition: background-color 0.2s ease; }
        .upgradeItem button:hover:not(:disabled) { background-color: #45a049; }
        .upgradeItem button:disabled { background-color: #555; color: #999; cursor: not-allowed; }
        .upgradeItem.purchased button, .upgradeItem.maxed button { background-color: #0a631a; color: #ccc; cursor: default; }
        .upgradeItem.purchased button:hover, .upgradeItem.maxed button:hover { background-color: #0a631a; }
        #shopOverlay {}
        #shopOverlay h2 { font-size: 40px; }
        #shopCashOverlay { font-size: 24px; margin-bottom: 20px; color: #FFEB3B; font-weight: bold; }
        #shopItemsContainerOverlay { display: flex; flex-direction: column; gap: 15px; margin-top: 10px; margin-bottom: 20px; max-width: 90%; max-height: 60vh; overflow-y: auto; align-items: center; padding: 0 10px; }
        .shopItemOverlay { background-color: rgba(255, 255, 255, 0.1); padding: 15px; border-radius: 8px; display: flex; justify-content: space-between; align-items: center; width: 90%; max-width: 450px; font-size: 18px; box-shadow: 0 2px 5px rgba(0,0,0,0.3); }
        .shopItemOverlay .description { flex-grow: 1; text-align: left; margin-left: 10px; }
        .shopItemOverlay .description .name { font-weight: bold; display: block; margin-bottom: 3px; }
        .shopItemOverlay .description .details { font-size: 14px; opacity: 0.8; }
        .shopItemOverlay .cost { font-weight: bold; color: #FFEB3B; margin: 0 15px; font-size: 16px; }
        .shopItemOverlay button { font-size: 16px; padding: 8px 15px; margin-top: 0; min-width: 90px; }
        .shopItemOverlay.purchased button, .shopItemOverlay.maxed button { background-color: #0a631a; color: #ccc; cursor: default; }
        .shopItemOverlay.purchased button:hover, .shopItemOverlay.maxed button:hover { background-color: #0a631a; }

        /* Media Query Mobile */
        @media (max-width: 600px) {
            #cashDisplay, #health { font-size: 18px; top: 10px; } #cashDisplay { left: 10px; } #health { right: 10px; }
            #waveIndicator { font-size: 14px; top: 40px; left: 10px; }
            #pauseBtn { font-size: 14px; padding: 8px 10px; bottom: 10px; right: 10px; }
            #upgradePanel { max-width: 220px; padding: 8px 10px; bottom: 10px; left: 10px; }
            #upgradePanel h3 { font-size: 14px; margin-bottom: 8px; }
            .upgradeItem { font-size: 12px; margin-bottom: 5px; } .upgradeItem .info { margin-right: 5px; }
            .upgradeItem .name { font-size: 11px; } .upgradeItem .cost { font-size: 11px; }
            .upgradeItem .details { display: none; } /* Esconde detalhes no painel mobile */
            .upgradeItem button { padding: 3px 6px; font-size: 10px; min-width: 45px; }
            .menuOverlay { font-size: 36px; } .menuOverlay h1 { font-size: 42px; } .menuOverlay h2 { font-size: 38px; }
            .menuOverlay button { font-size: 18px; padding: 10px 20px; }
            #shopItemsContainerOverlay { max-width: 100%; padding: 0 5px; }
            .shopItemOverlay { width: 100%; font-size: 16px; padding: 10px; } .shopItemOverlay .description .details { font-size: 12px; }
            .shopItemOverlay .cost { font-size: 14px; margin: 0 10px; } .shopItemOverlay button { font-size: 14px; padding: 6px 12px; min-width: 70px; }
        }
         /* NOVO: Estilo para inimigo infectado (pode melhorar) */
         .infected-glow {
             box-shadow: 0 0 15px 5px rgba(76, 175, 80, 0.7); /* Brilho verde */
         }
    </style>
</head>
<body>
    <div id="gameUI">
        <div id="cashDisplay">Cash: 0</div> <div id="health">Health: 100</div> <div id="waveIndicator">Wave: 0</div>
        <button id="pauseBtn" class="gameButton" style="display: none;">Pause</button>
        <div id="upgradePanel" style="display: none;"> <h3>Upgrades</h3> <div id="upgradeItemsContainer"></div> </div>
        <div id="startScreen" class="menuOverlay visible"> <h1>Circle Shooter</h1> <div id="startScreenButtons"> <button id="startBtn">Iniciar Jogo</button> <button id="startShopBtn">Loja</button> </div> </div>
        <div id="gameOver" class="menuOverlay"> <h2>Game Over</h2> <span id="finalCash"></span> <button id="restartBtn">Tela Inicial</button> </div>
        <div id="pauseMenu" class="menuOverlay"> <h2>Game Paused</h2> <button id="resumeBtn">Resume</button> </div>
        <div id="shopOverlay" class="menuOverlay"> <h2>Loja de Upgrades</h2> <div id="shopCashOverlay">Cash: 0</div> <div id="shopItemsContainerOverlay"></div> <button id="closeShopOverlayBtn">Voltar</button> </div>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        // --- Seletores (sem mudanças) ---
        const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d');
        const cashElement = document.getElementById('cashDisplay'); const healthElement = document.getElementById('health'); const waveIndicatorElement = document.getElementById('waveIndicator');
        const startScreen = document.getElementById('startScreen'); const startBtn = document.getElementById('startBtn'); const startShopBtn = document.getElementById('startShopBtn');
        const gameOverElement = document.getElementById('gameOver'); const finalCashElement = document.getElementById('finalCash'); const restartBtn = document.getElementById('restartBtn');
        const pauseBtn = document.getElementById('pauseBtn'); const pauseMenu = document.getElementById('pauseMenu'); const resumeBtn = document.getElementById('resumeBtn');
        const upgradePanel = document.getElementById('upgradePanel'); const upgradeItemsContainer = document.getElementById('upgradeItemsContainer');
        const shopOverlay = document.getElementById('shopOverlay'); const shopCashOverlayElement = document.getElementById('shopCashOverlay'); const shopItemsContainerOverlay = document.getElementById('shopItemsContainerOverlay'); const closeShopOverlayBtn = document.getElementById('closeShopOverlayBtn');

        // --- Constantes ---
        // ... (Constantes anteriores) ...
        const PLAYER_COLOR = '#4CAF50'; const PLAYER_RADIUS = 20;
        const BULLET_COLOR = '#2196F3'; const BULLET_RADIUS = 5; const BASE_BULLET_SPEED = 7; const BASE_BULLET_DAMAGE = 10;
        const ENEMY_CIRCLE_COLOR = '#F44336'; const ENEMY_SQUARE_COLOR = '#FF9800'; const ENEMY_TRIANGLE_COLOR = '#9C27B0';
        const BASE_ENEMY_RADIUS = 15; const BASE_ENEMY_HEALTH = 30; const BASE_ENEMY_SPEED = 0.5; const ENEMY_SPEED_RANDOMNESS = 0.3;
        const SHIELD_COLOR = '#FFEB3B'; const BASE_SHIELD_ACTIVE_DURATION = 5000; const BASE_SHIELD_COOLDOWN_DURATION = 8000; const MAX_WEAPON_LEVEL = 3;
        const BOSS_WAVE_INTERVAL = 10; const BOSS_COLOR = '#E91E63'; const BOSS_HEALTH_MULTIPLIER = 30; const BOSS_RADIUS_MULTIPLIER = 2.5; const BOSS_MINION_SPAWN_COOLDOWN = 6000; const BOSS_MINION_COUNT = 3;
        const POWERUP_DROP_CHANCE = 0.08; const POWERUP_DURATION = 7000;
        const POWERUP_ATTRACTION_SPEED = 4; // NOVO: Velocidade que powerups voam pro player
        const POWERUP_ATTRACTION_START_DISTANCE = 150; // NOVO: Distância para começar a atrair

        // Custos
        const SHIELD_UNLOCK_COST = 150; const WEAPON_LEVEL_COST = 100; const DAMAGE_UP_COST = 120;
        const FIRE_RATE_COST = 130; const BULLET_SPEED_COST = 90; const SHIELD_DURATION_COST = 110; const SHIELD_COOLDOWN_COST = 140;
        const NANO_BOT_UNLOCK_COST = 250; // NOVO

        // Valores Upgrades
        const DAMAGE_INCREASE_AMOUNT = 0.20; const FIRE_RATE_INCREASE = 0.15; const BULLET_SPEED_INCREASE = 0.10;
        const SHIELD_DURATION_INCREASE = 1000; const SHIELD_COOLDOWN_DECREASE = 750; const MIN_SHIELD_COOLDOWN = 2000;
        const NANO_BOT_COOLDOWN = 8000; // NOVO: Tempo para lançar novo bot
        const NANO_BOT_SPEED = 5;       // NOVO: Velocidade do bot
        const NANO_BOT_INFECTION_TIME = 3000; // NOVO: Tempo para infectar (ms)
        const CONVERTED_DURATION = 10000; // NOVO: Tempo que inimigo fica convertido (ms)
        const CONVERTED_ENEMY_RADIUS_FACTOR = 0.7; // NOVO: Tamanho do inimigo convertido
        const CONVERTED_SHOOT_COOLDOWN = 1500; // NOVO: Cooldown de tiro do convertido
        const CONVERTED_BULLET_SPEED = 4;    // NOVO
        const CONVERTED_BULLET_RADIUS = 4;     // NOVO
        const CONVERTED_BULLET_DAMAGE = 5;     // NOVO
        const CONVERTED_BULLET_COLOR = '#00FF00'; // NOVO

        // Chaves LocalStorage
        const STORAGE_KEY_PREFIX = 'circleShooterNano_'; // Novo prefixo para evitar conflitos
        const STORAGE_KEY_CASH = STORAGE_KEY_PREFIX + 'cash';
        const STORAGE_KEY_SHIELD_UNLOCKED = STORAGE_KEY_PREFIX + 'shieldUnlocked';
        const STORAGE_KEY_WEAPON_LEVEL = STORAGE_KEY_PREFIX + 'weaponLevel';
        const STORAGE_KEY_DAMAGE_MULTIPLIER = STORAGE_KEY_PREFIX + 'damageMultiplier';
        const STORAGE_KEY_FIRE_RATE_LEVEL = STORAGE_KEY_PREFIX + 'fireRateLevel';
        const STORAGE_KEY_BULLET_SPEED_LEVEL = STORAGE_KEY_PREFIX + 'bulletSpeedLevel';
        const STORAGE_KEY_SHIELD_DURATION_LEVEL = STORAGE_KEY_PREFIX + 'shieldDurationLevel';
        const STORAGE_KEY_SHIELD_COOLDOWN_LEVEL = STORAGE_KEY_PREFIX + 'shieldCooldownLevel';
        const STORAGE_KEY_NANO_BOTS_UNLOCKED = STORAGE_KEY_PREFIX + 'nanoBotsUnlocked'; // NOVO

        // --- Estado do Jogo ---
        let cash = 0; let health = 100; let gameState = 'start';
        let enemies = []; let bullets = []; let particles = []; let powerups = []; let nanoBots = []; // NOVO: Array para nanobots
        let bossActive = false; let lastEnemySpawnTime = 0; let enemySpawnInterval = 3000; let baseEnemySpawnInterval = 3000; let minEnemySpawnInterval = 400;
        let lastBulletTime = 0; let aimX = 0, aimY = 0; let currentWave = 0;
        let shakeIntensity = 0; let shakeDuration = 0;
        let nanoBotCooldownTimer = 0; // NOVO: Timer para lançar próximo bot

        // --- Estado do Jogador ---
        const player = {
            x: 0, y: 0, radius: PLAYER_RADIUS, color: PLAYER_COLOR,
            // Persistentes
            shieldUnlocked: false, weaponLevel: 0, damageMultiplier: 1,
            fireRateLevel: 0, bulletSpeedLevel: 0, shieldDurationLevel: 0, shieldCooldownLevel: 0,
            nanoBotsUnlocked: false, // NOVO
            // Não persistentes
            shieldActive: false, shieldState: 'inactive', shieldTimer: 0,
            activePowerups: {},
        };

        // --- Funções Utilitárias ---
        // NOVO: Interpolação linear de cores (simples, pode precisar de biblioteca para cores complexas)
        function lerpColor(colorA, colorB, t) {
             const hexToRgb = hex => hex.match(/\w\w/g).map(x => parseInt(x, 16));
             const rgbToHex = rgb => '#' + rgb.map(x => { const hex = x.toString(16); return hex.length === 1 ? '0' + hex : hex; }).join('');

             const rgbA = hexToRgb(colorA);
             const rgbB = hexToRgb(colorB);

             const rgb = rgbA.map((start, i) => {
                 const end = rgbB[i];
                 return Math.round(start + (end - start) * t);
             });

             return rgbToHex(rgb);
        }

        // --- Funções de Persistência (adicionado nanoBotsUnlocked) ---
        function loadGameData() {
            cash = parseInt(localStorage.getItem(STORAGE_KEY_CASH) || '0');
            player.shieldUnlocked = localStorage.getItem(STORAGE_KEY_SHIELD_UNLOCKED) === 'true';
            player.weaponLevel = parseInt(localStorage.getItem(STORAGE_KEY_WEAPON_LEVEL) || '0');
            player.damageMultiplier = Math.max(1, parseFloat(localStorage.getItem(STORAGE_KEY_DAMAGE_MULTIPLIER) || '1'));
            player.fireRateLevel = parseInt(localStorage.getItem(STORAGE_KEY_FIRE_RATE_LEVEL) || '0');
            player.bulletSpeedLevel = parseInt(localStorage.getItem(STORAGE_KEY_BULLET_SPEED_LEVEL) || '0');
            player.shieldDurationLevel = parseInt(localStorage.getItem(STORAGE_KEY_SHIELD_DURATION_LEVEL) || '0');
            player.shieldCooldownLevel = parseInt(localStorage.getItem(STORAGE_KEY_SHIELD_COOLDOWN_LEVEL) || '0');
            player.nanoBotsUnlocked = localStorage.getItem(STORAGE_KEY_NANO_BOTS_UNLOCKED) === 'true'; // NOVO
            updateCashDisplay();
        }
        function saveGameData() {
            localStorage.setItem(STORAGE_KEY_CASH, cash.toString());
            localStorage.setItem(STORAGE_KEY_SHIELD_UNLOCKED, player.shieldUnlocked.toString());
            localStorage.setItem(STORAGE_KEY_WEAPON_LEVEL, player.weaponLevel.toString());
            localStorage.setItem(STORAGE_KEY_DAMAGE_MULTIPLIER, player.damageMultiplier.toString());
            localStorage.setItem(STORAGE_KEY_FIRE_RATE_LEVEL, player.fireRateLevel.toString());
            localStorage.setItem(STORAGE_KEY_BULLET_SPEED_LEVEL, player.bulletSpeedLevel.toString());
            localStorage.setItem(STORAGE_KEY_SHIELD_DURATION_LEVEL, player.shieldDurationLevel.toString());
            localStorage.setItem(STORAGE_KEY_SHIELD_COOLDOWN_LEVEL, player.shieldCooldownLevel.toString());
            localStorage.setItem(STORAGE_KEY_NANO_BOTS_UNLOCKED, player.nanoBotsUnlocked.toString()); // NOVO
        }

        // --- Configuração Inicial e Controles (sem mudanças) ---
        function resizeCanvas() { /* ... */ } window.addEventListener('resize', resizeCanvas);
        function updateAimPosition(event) { /* ... */ }
        canvas.addEventListener('mousemove', (e) => { if (gameState === 'playing') updateAimPosition(e); });
        canvas.addEventListener('touchmove', (e) => { if (gameState === 'playing') { e.preventDefault(); updateAimPosition(e); } }, { passive: false });
        canvas.addEventListener('touchstart', (e) => { if (gameState === 'playing') { e.preventDefault(); updateAimPosition(e); } }, { passive: false });
        window.addEventListener('keydown', (e) => { /* ... (pausa, atalhos numéricos) ... */
             if (e.key === 'Escape' || e.key === 'p' || e.key === 'P') { if (gameState === 'shoppingOverlay') { closeShopOverlay(); } else if (gameState === 'playing' || gameState === 'paused') { togglePause(); } }
             if (gameState === 'playing') {
                 switch(e.key) {
                     case '1': buyUpgradeByIndex(0); break; case '2': buyUpgradeByIndex(1); break; case '3': buyUpgradeByIndex(2); break; case '4': buyUpgradeByIndex(3); break;
                     case '5': buyUpgradeByIndex(4); break; case '6': buyUpgradeByIndex(5); break; case '7': buyUpgradeByIndex(6); break; case '8': buyUpgradeByIndex(7); break; // NOVO: Atalho 8 para nanobots
                 }
             }
         });

        // --- Lógica da Loja Overlay (sem mudanças na estrutura) ---
        function openShopOverlay() { /* ... */ } function closeShopOverlay() { /* ... */ }
        function updateShopOverlayUI() { /* ... */ } function createShopOverlayItem(upgrade) { /* ... */ }

        // --- Event Listeners da UI (sem mudanças) ---
        startBtn.addEventListener('click', startGame); startShopBtn.addEventListener('click', openShopOverlay);
        closeShopOverlayBtn.addEventListener('click', closeShopOverlay); pauseBtn.addEventListener('click', togglePause);
        resumeBtn.addEventListener('click', togglePause); restartBtn.addEventListener('click', () => { /* ... */ });

        // --- Funções de Controle do Jogo ---
        function startGame() { /* ... */ } function togglePause() { /* ... */ } function showGameOver() { /* ... */ }
        function resetGameSession() {
            health = 100; enemies = []; bullets = []; particles = []; powerups = []; nanoBots = []; // NOVO: Limpa nanobots
            bossActive = false; player.activePowerups = {};
            player.shieldState = 'inactive'; player.shieldTimer = 0; player.shieldActive = false;
            player.x = canvas.width / 2; player.y = canvas.height / 2;
            lastEnemySpawnTime = 0; enemySpawnInterval = baseEnemySpawnInterval; currentWave = 0;
            aimX = canvas.width / 2; aimY = canvas.height / 2;
            nanoBotCooldownTimer = 0; // NOVO: Reseta timer do bot
            updateHealth(); updateWaveIndicator();
            ctx.fillStyle = '#222'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // --- Lógica de Upgrades (Adicionado NanoBots) ---
        function getCurrentFireRateCooldown() { /* ... */ } function getCurrentBulletSpeed() { /* ... */ }
        function getCurrentShieldActiveDuration() { /* ... */ } function getCurrentShieldCooldownDuration() { /* ... */ }

        const upgrades = [
            { /* Shield Unlock */ id: 'shieldUnlock', name: "Desbloquear Escudo", cost: SHIELD_UNLOCK_COST, isPurchased: () => player.shieldUnlocked, buy: () => { /*...*/ return true; }, getDescription: () => `Ativa ${getCurrentShieldActiveDuration()/1000}s, Recarrega ${getCurrentShieldCooldownDuration()/1000}s` },
            { /* Weapon Level */ id: 'weaponLevel', name: "Nível Arma", cost: () => WEAPON_LEVEL_COST * (player.weaponLevel + 1), maxLevel: MAX_WEAPON_LEVEL, isMaxed: () => player.weaponLevel >= MAX_WEAPON_LEVEL, buy: () => { /*...*/ return true; }, getDescription: () => `Projéteis: ${player.weaponLevel}/${MAX_WEAPON_LEVEL}. Próximo Custo: ${upgrades[1].isMaxed() ? 'MAX' : upgrades[1].cost()}` },
            { /* Damage Up */ id: 'damageUp', name: "Dano", cost: () => Math.floor(DAMAGE_UP_COST * (1 + (player.damageMultiplier - 1) / DAMAGE_INCREASE_AMOUNT) * 1.2), buy: () => { /*...*/ return true; }, getDescription: () => `+${(DAMAGE_INCREASE_AMOUNT * 100).toFixed(0)}%. Atual: ${(player.damageMultiplier * 100).toFixed(0)}%. Custo: ${upgrades[2].cost()}` },
            { /* Fire Rate */ id: 'fireRate', name: "Cadência", cost: () => FIRE_RATE_COST * (player.fireRateLevel + 1), buy: () => { /*...*/ return true; }, getDescription: () => `+${(FIRE_RATE_INCREASE * 100).toFixed(0)}% Vel. Disparo. Nível: ${player.fireRateLevel}. Custo: ${upgrades[3].cost()}` },
            { /* Bullet Speed */ id: 'bulletSpeed', name: "Vel. Projétil", cost: () => BULLET_SPEED_COST * (player.bulletSpeedLevel + 1), buy: () => { /*...*/ return true; }, getDescription: () => `+${(BULLET_SPEED_INCREASE * 100).toFixed(0)}% Vel. Projétil. Nível: ${player.bulletSpeedLevel}. Custo: ${upgrades[4].cost()}` },
            { /* Shield Duration */ id: 'shieldDuration', name: "Duração Escudo", cost: () => SHIELD_DURATION_COST * (player.shieldDurationLevel + 1), requiresShield: true, buy: () => { /*...*/ return true; }, getDescription: () => `+${SHIELD_DURATION_INCREASE/1000}s Duração. Atual: ${getCurrentShieldActiveDuration()/1000}s. Custo: ${upgrades[5].cost()}` },
            { /* Shield Cooldown */ id: 'shieldCooldown', name: "Recarga Escudo", cost: () => SHIELD_COOLDOWN_COST * (player.shieldCooldownLevel + 1), requiresShield: true, isMaxed: () => getCurrentShieldCooldownDuration() <= MIN_SHIELD_COOLDOWN, buy: () => { /*...*/ return true; }, getDescription: () => `-${SHIELD_COOLDOWN_DECREASE/1000}s Recarga. Atual: ${getCurrentShieldCooldownDuration()/1000}s. Custo: ${upgrades[6].isMaxed() ? 'MAX' : upgrades[6].cost()}` },
             // NOVO: Upgrade NanoBots
             {
                 id: 'nanoBots',
                 name: "Nano-Robôs",
                 cost: NANO_BOT_UNLOCK_COST,
                 isPurchased: () => player.nanoBotsUnlocked,
                 buy: () => {
                     if (cash >= NANO_BOT_UNLOCK_COST && !player.nanoBotsUnlocked) {
                         cash -= NANO_BOT_UNLOCK_COST;
                         player.nanoBotsUnlocked = true;
                         nanoBotCooldownTimer = NANO_BOT_COOLDOWN; // Dá um cooldown inicial
                         return true;
                     }
                     return false;
                 },
                 getDescription: () => `Lança robôs que convertem inimigos temporariamente. Custo: ${NANO_BOT_UNLOCK_COST}`
             }
        ];

        // --- Lógica do Jogo ---
        function createParticles(...) { /* ... */ } function updateParticles(...) { /* ... */ }
        function triggerShake(...) { /* ... */ } function updateShake(...) { /* ... */ }
        function updateShield(...) { /* ... */ } function updateActivePowerups(...) { /* ... */ }
        function spawnPowerup(...) { /* ... */ }
        function spawnEnemy() { /* ... */ } function spawnBoss() { /* ... */ } function spawnMinionsAroundBoss(...) { /* ... */ }

        // MODIFICADO: updatePowerups com atração
        function updatePowerups(deltaTime) {
            for (let i = powerups.length - 1; i >= 0; i--) {
                const powerup = powerups[i];
                powerup.life -= deltaTime;

                const dx = player.x - powerup.x;
                const dy = player.y - powerup.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Atração
                if (distance < POWERUP_ATTRACTION_START_DISTANCE) {
                    const speed = POWERUP_ATTRACTION_SPEED * (1 + (1 - distance/POWERUP_ATTRACTION_START_DISTANCE)); // Acelera perto
                    if (distance > 1) { // Evita divisão por zero e jitter
                        powerup.x += (dx / distance) * speed * (deltaTime / 16.67);
                        powerup.y += (dy / distance) * speed * (deltaTime / 16.67);
                    }
                }
                 // Se não está perto, pode ter um movimento leve (opcional)
                 // else { powerup.y += 0.5 * (deltaTime / 16.67); } // Queda lenta original

                // Colisão com jogador
                if (distance < player.radius + powerup.radius) {
                    player.activePowerups[powerup.type] = Date.now() + POWERUP_DURATION;
                    if (powerup.type === 'rapidFire') player.color = '#FFFF00';
                    if (powerup.type === 'cashBoost') { const cashBonus = 50 + Math.floor(Math.random() * 51); cash += cashBonus; updateCashDisplay(); saveGameData(); createParticles(player.x, player.y, 15, '#FFEB3B'); }
                    createParticles(powerup.x, powerup.y, 10, powerup.color);
                    powerups.splice(i, 1);
                    continue;
                }

                // Remove se expirar
                if (powerup.life <= 0) {
                    powerups.splice(i, 1);
                }
            }
        }

        // NOVO: Lógica dos NanoBots
        function launchNanoBot() {
             if (!player.nanoBotsUnlocked || nanoBotCooldownTimer > 0 || nanoBots.length > 0) { // Só lança 1 por vez por enquanto
                 return;
             }

             let targetEnemy = null;
             let maxHealth = -1;

             // Encontra inimigo (não convertido, não boss) com mais vida
             for (const enemy of enemies) {
                 if (!enemy.isConverted && !enemy.isBoss && enemy.health > maxHealth) {
                     // Verifica se já tem um bot indo para este inimigo
                     let alreadyTargeted = false;
                     for(const bot of nanoBots) {
                         if (bot.targetEnemy === enemy) {
                             alreadyTargeted = true;
                             break;
                         }
                     }
                     if (!alreadyTargeted) {
                         maxHealth = enemy.health;
                         targetEnemy = enemy;
                     }
                 }
             }

             if (targetEnemy) {
                 nanoBots.push({
                     x: player.x,
                     y: player.y,
                     radius: 4,
                     color: '#00BCD4', // Ciano para o bot
                     targetEnemy: targetEnemy,
                     state: 'seeking', // 'seeking', 'infecting'
                     infectionProgress: 0,
                     speed: NANO_BOT_SPEED
                 });
                 nanoBotCooldownTimer = NANO_BOT_COOLDOWN; // Inicia cooldown
                 createParticles(player.x, player.y, 5, '#00BCD4', 0.8, 0.5); // Efeito de lançamento
             }
        }

        function updateNanoBots(deltaTime) {
            // Atualiza cooldown global
            if (nanoBotCooldownTimer > 0) {
                nanoBotCooldownTimer -= deltaTime;
            }

            for (let i = nanoBots.length - 1; i >= 0; i--) {
                const bot = nanoBots[i];
                const target = bot.targetEnemy;

                // Se o alvo morreu ou foi convertido enquanto o bot estava a caminho
                if (!target || target.health <= 0 || target.isConverted) {
                     createParticles(bot.x, bot.y, 5, bot.color, 0.5, 0.5); // Bot se desfaz
                     nanoBots.splice(i, 1);
                     continue;
                }

                if (bot.state === 'seeking') {
                    const dx = target.x - bot.x;
                    const dy = target.y - bot.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < bot.radius + target.radius) {
                        // Chegou ao alvo
                        bot.state = 'infecting';
                        createParticles(target.x, target.y, 8, bot.color, 0.7, 0.8); // Efeito de início da infecção
                    } else {
                        // Move towards target
                        bot.x += (dx / distance) * bot.speed * (deltaTime / 16.67);
                        bot.y += (dy / distance) * bot.speed * (deltaTime / 16.67);
                    }
                } else if (bot.state === 'infecting') {
                     // Fica "preso" visualmente ao alvo (opcional, pode só parar de mover)
                     bot.x = target.x + (Math.random() - 0.5) * target.radius * 0.5;
                     bot.y = target.y + (Math.random() - 0.5) * target.radius * 0.5;

                    bot.infectionProgress += deltaTime / NANO_BOT_INFECTION_TIME;
                    target.infectionProgress = bot.infectionProgress; // Passa progresso para o inimigo (para desenho)

                    if (bot.infectionProgress >= 1) {
                        // Infecção completa! Converter o inimigo.
                        convertEnemy(target);
                        nanoBots.splice(i, 1); // Bot desaparece
                    }
                }
            }
        }

        // NOVO: Função para converter um inimigo
        function convertEnemy(enemy) {
             if (enemy.isConverted) return; // Já convertido

             enemy.isConverted = true;
             enemy.originalColor = enemy.color; // Guarda cor original se precisar reverter
             enemy.color = PLAYER_COLOR;
             enemy.originalRadius = enemy.radius;
             enemy.radius *= CONVERTED_ENEMY_RADIUS_FACTOR; // Fica menor
             enemy.speed = 0; // Para de seguir jogador
             enemy.dx = 0;
             enemy.dy = 0;
             enemy.convertedTimer = CONVERTED_DURATION;
             enemy.shootTimer = Math.random() * CONVERTED_SHOOT_COOLDOWN; // Cooldown inicial aleatório
             enemy.targetConvertedEnemy = null; // Reseta alvo
             delete enemy.infectionProgress; // Remove progresso da infecção

             createParticles(enemy.x, enemy.y, 20, PLAYER_COLOR, 1.2, 1.0); // Efeito visual forte da conversão
        }

        function updateEnemies(deltaTime) {
            updateShield(deltaTime);

            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];

                // --- Lógica para Inimigos Convertidos ---
                if (enemy.isConverted) {
                    enemy.convertedTimer -= deltaTime;
                    if (enemy.convertedTimer <= 0) {
                         createParticles(enemy.x, enemy.y, 15, enemy.color, 1, 1); // Efeito de desaparecimento
                         enemies.splice(i, 1);
                         continue;
                    }

                    // Lógica de Atirar do Convertido
                    enemy.shootTimer -= deltaTime;
                    if (enemy.shootTimer <= 0) {
                         // Encontra alvo (inimigo não convertido mais próximo)
                         let closestEnemy = null;
                         let minDistSq = Infinity;
                         for (const otherEnemy of enemies) {
                             if (!otherEnemy.isConverted && otherEnemy !== enemy) { // Não atira em si mesmo ou outros convertidos
                                 const dx = otherEnemy.x - enemy.x;
                                 const dy = otherEnemy.y - enemy.y;
                                 const distSq = dx * dx + dy * dy;
                                 if (distSq < minDistSq) {
                                     minDistSq = distSq;
                                     closestEnemy = otherEnemy;
                                 }
                             }
                         }

                         if (closestEnemy) {
                             const angle = Math.atan2(closestEnemy.y - enemy.y, closestEnemy.x - enemy.x);
                             bullets.push({
                                 x: enemy.x, y: enemy.y,
                                 radius: CONVERTED_BULLET_RADIUS,
                                 color: CONVERTED_BULLET_COLOR,
                                 speed: CONVERTED_BULLET_SPEED,
                                 damage: CONVERTED_BULLET_DAMAGE,
                                 dx: Math.cos(angle) * CONVERTED_BULLET_SPEED,
                                 dy: Math.sin(angle) * CONVERTED_BULLET_SPEED,
                                 isConvertedBullet: true // Flag especial
                             });
                             enemy.shootTimer = CONVERTED_SHOOT_COOLDOWN + (Math.random() - 0.5) * 500; // Reseta cooldown com variação
                              createParticles(enemy.x, enemy.y, 2, CONVERTED_BULLET_COLOR, 0.5, 0.5); // Efeito de tiro
                         } else {
                              enemy.shootTimer = 500; // Tenta de novo em breve se não achar alvo
                         }
                    }
                     // Fica parado, não precisa atualizar dx/dy
                }
                // --- Lógica para Inimigos Normais e Boss ---
                else {
                    enemy.updateDirection(deltaTime);
                    enemy.x += enemy.dx * (deltaTime / 16.67);
                    enemy.y += enemy.dy * (deltaTime / 16.67);

                    // Colisão com jogador (inalterada)
                    const dx = player.x - enemy.x; const dy = player.y - enemy.y; const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < player.radius + enemy.radius) {
                        if (player.shieldActive) {
                            const shieldDamage = 5 + player.shieldDurationLevel; const died = enemy.takeDamage(shieldDamage);
                            createParticles(enemy.x, enemy.y, 5, SHIELD_COLOR, 1, 0.7);
                            if (died && !enemy.isBoss) { enemy.die(); enemies.splice(i, 1); } // Boss não morre com escudo
                            else { const pushAngle = Math.atan2(enemy.y - player.y, enemy.x - player.x); enemy.x += Math.cos(pushAngle) * 5; enemy.y += Math.sin(pushAngle) * 5; }
                        } else {
                            const damageTaken = enemy.isBoss ? 30 : 15; health -= damageTaken;
                            triggerShake(enemy.isBoss ? 10 : 5, 200); createParticles(player.x, player.y, 10, '#FF0000', 1.5, 1.0);
                            updateHealth();
                            if (!enemy.isBoss) { enemy.die(); enemies.splice(i, 1); }
                            else { const pushAngle = Math.atan2(enemy.y - player.y, enemy.x - player.x); enemy.x += Math.cos(pushAngle) * 15; enemy.y += Math.sin(pushAngle) * 15; }
                            if (health <= 0) { health = 0; updateHealth(); showGameOver(); return; }
                        }
                        continue; // Já tratou colisão com jogador
                    }
                } // Fim do else (inimigo normal/boss)
            } // Fim do loop de inimigos
        }


        function shoot() { /* ... (lógica de tiro do jogador - sem mudanças) ... */ }

        // MODIFICADO: updateBullets para lidar com balas convertidas
        function updateBullets(deltaTime) {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.x += bullet.dx * (deltaTime / 16.67);
                bullet.y += bullet.dy * (deltaTime / 16.67);
                let bulletRemoved = false;

                // Colisão Bala do Jogador vs Inimigos Normais/Boss
                if (!bullet.isConvertedBullet) {
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const enemy = enemies[j];
                        if (enemy.isConverted) continue; // Bala do jogador não atinge convertidos

                        const dx = bullet.x - enemy.x; const dy = bullet.y - enemy.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < bullet.radius + enemy.radius) {
                            const died = enemy.takeDamage(bullet.damage);
                            createParticles(bullet.x, bullet.y, 3, enemy.color, 0.8, 0.6);
                            bullets.splice(i, 1); bulletRemoved = true;
                            if (died) { enemy.die(); enemies.splice(j, 1); }
                            break;
                        }
                    }
                }
                // NOVO: Colisão Bala Convertida vs Inimigos Normais/Boss
                else { // isConvertedBullet === true
                     for (let j = enemies.length - 1; j >= 0; j--) {
                         const enemy = enemies[j];
                         if (enemy.isConverted) continue; // Bala convertida não atinge outros convertidos

                         const dx = bullet.x - enemy.x; const dy = bullet.y - enemy.y;
                         const distance = Math.sqrt(dx * dx + dy * dy);
                         if (distance < bullet.radius + enemy.radius) {
                             const died = enemy.takeDamage(bullet.damage); // Dano baixo da bala convertida
                             createParticles(bullet.x, bullet.y, 2, CONVERTED_BULLET_COLOR, 0.6, 0.5); // Efeito verde
                             bullets.splice(i, 1); bulletRemoved = true;
                             if (died) { enemy.die(); enemies.splice(j, 1); } // Inimigo normal morre, ganha cash/drop normal
                             break;
                         }
                     }
                }

                // Remove bala se saiu da tela
                if (!bulletRemoved && (bullet.x < -bullet.radius || bullet.x > canvas.width + bullet.radius || bullet.y < -bullet.radius || bullet.y > canvas.height + bullet.radius)) {
                    bullets.splice(i, 1);
                }
            }
        }


        // --- Desenho (adicionado desenho de nanobots e infecção/conversão) ---
        function draw() {
            let shakeX = 0, shakeY = 0; if (shakeIntensity > 0) { shakeX = (Math.random() - 0.5) * 2 * shakeIntensity; shakeY = (Math.random() - 0.5) * 2 * shakeIntensity; }
            ctx.save(); ctx.translate(shakeX, shakeY);

            ctx.fillStyle = '#222'; ctx.fillRect(0, 0, canvas.width, canvas.height); // Limpa

            // Desenha Partículas, Powerups (sem mudanças)
            ctx.globalAlpha = 0.8; for (const p of particles) { ctx.beginPath(); ctx.arc(p.x, p.y, p.radius * (p.life / p.maxLife), 0, Math.PI * 2); ctx.fillStyle = p.color; ctx.fill(); } ctx.globalAlpha = 1.0;
            for (const powerup of powerups) { /* ... */ }

             // NOVO: Desenha NanoBots ativos
             ctx.fillStyle = '#00BCD4'; // Ciano
             ctx.strokeStyle = '#FFFFFF';
             ctx.lineWidth = 1;
             for (const bot of nanoBots) {
                 ctx.beginPath();
                 // Desenha como um pequeno losango/quadrado rotacionado
                 const size = bot.radius * 1.5;
                 ctx.moveTo(bot.x, bot.y - size);
                 ctx.lineTo(bot.x + size, bot.y);
                 ctx.lineTo(bot.x, bot.y + size);
                 ctx.lineTo(bot.x - size, bot.y);
                 ctx.closePath();
                 ctx.fill();
                 ctx.stroke();
             }

            // Desenha Jogador, Aura, Escudo (sem mudanças)
            ctx.beginPath(); ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2); ctx.fillStyle = player.activePowerups.rapidFire ? '#FFFF00' : PLAYER_COLOR; ctx.fill();
            if (player.weaponLevel > 0) { /* ... */ } if (player.shieldUnlocked) { /* ... */ }

            // Desenha Inimigos
            for (const enemy of enemies) {
                ctx.save(); // Salva estado para aplicar efeitos específicos
                ctx.beginPath();

                let drawColor = enemy.color;
                let drawRadius = enemy.radius;

                // Efeito de Infecção (antes de desenhar a forma)
                if (enemy.infectionProgress > 0 && enemy.infectionProgress < 1) {
                     drawColor = lerpColor(enemy.color, PLAYER_COLOR, enemy.infectionProgress);
                     // Efeito visual de "pulsação" ou brilho durante infecção
                     const infectionPulse = Math.sin(Date.now() * 0.01 + enemy.infectionProgress * Math.PI) * 3;
                     ctx.shadowColor = bot.color; // Usa cor do bot (ciano) para o brilho da infecção
                     ctx.shadowBlur = 5 + infectionPulse;
                } else if (enemy.isConverted) {
                     // Os convertidos já têm a cor do player e raio menor
                     drawColor = PLAYER_COLOR;
                     drawRadius = enemy.originalRadius * CONVERTED_ENEMY_RADIUS_FACTOR;
                      // Brilho sutil verde para convertidos
                      ctx.shadowColor = CONVERTED_BULLET_COLOR;
                      ctx.shadowBlur = 8;
                }


                // Desenha Forma (círculo, quadrado, triângulo ou CONVERTIDO)
                 if (enemy.isConverted) {
                      // Desenha como círculo menor (forma do player)
                      ctx.arc(enemy.x, enemy.y, drawRadius, 0, Math.PI * 2);
                 } else if (enemy.type === 'circle' || enemy.isBoss) { ctx.arc(enemy.x, enemy.y, drawRadius, 0, Math.PI * 2); }
                 else if (enemy.type === 'square') { ctx.rect(enemy.x - drawRadius, enemy.y - drawRadius, drawRadius * 2, drawRadius * 2); }
                 else if (enemy.type === 'triangle') { const angleOffset = Date.now() * 0.001; for (let i = 0; i < 3; i++) { const angle = (i * 2 * Math.PI / 3) + angleOffset; const px = enemy.x + Math.cos(angle) * drawRadius * 1.2; const py = enemy.y + Math.sin(angle) * drawRadius * 1.2; if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py); } ctx.closePath(); }

                 ctx.fillStyle = drawColor;
                 ctx.fill();
                 ctx.shadowColor = 'transparent'; // Limpa sombra para próximos elementos
                 ctx.shadowBlur = 0;

                 // Barra de Vida (não mostra para convertidos)
                 if (!enemy.isConverted && enemy.health < enemy.maxHealth) { /* ... */ }

                 ctx.restore(); // Restaura estado (remove sombras específicas)
            } // Fim do loop de inimigos

            // Desenha Balas (sem mudanças no desenho em si)
            for (const bullet of bullets) { /* ... */ ctx.beginPath(); ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2); ctx.fillStyle = bullet.color; ctx.shadowColor = bullet.color; ctx.shadowBlur = bullet.isConvertedBullet ? 4 : 6; ctx.fill(); ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; }

            ctx.restore(); // Restaura contexto (remove shake)
        }

        // --- UI Updates (sem mudanças) ---
        function updateCashDisplay() { /* ... */ } function updateHealth() { /* ... */ } function updateWaveIndicator() { /* ... */ }
        function updateUpgradePanel() { /* ... */ } function buyUpgradeByIndex(index) { /* ... */ }

        // --- Game Loop Principal (adicionado chamadas para nanobots) ---
        let lastTimestamp = 0;
        function gameLoop(timestamp) {
             const deltaTime = Math.min(100, (lastTimestamp === 0) ? 16.67 : timestamp - lastTimestamp);
             lastTimestamp = timestamp;

             if (gameState !== 'playing') { if(gameState === 'paused') { lastTimestamp = 0; } if (gameState === 'gameOver' || gameState === 'paused') { draw(); } return; }

            // Atualizações Lógicas
            updateShake(deltaTime); updateActivePowerups(deltaTime);
            launchNanoBot(); // NOVO: Tenta lançar um bot
            updateNanoBots(deltaTime); // NOVO: Atualiza bots existentes
            spawnEnemy(); updateEnemies(deltaTime); updatePowerups(deltaTime);
            shoot(); updateBullets(deltaTime); updateParticles(deltaTime);

            // Desenho
            draw();

            requestAnimationFrame(gameLoop);
        }

        // --- Início ---
        loadGameData(); resizeCanvas();
        startScreen.classList.add('visible'); gameOverElement.classList.remove('visible'); pauseMenu.classList.remove('visible'); shopOverlay.classList.remove('visible');
        pauseBtn.style.display = 'none'; upgradePanel.style.display = 'none';
        updateHealth(); updateWaveIndicator();

    </script>
</body>
</html>
